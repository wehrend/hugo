.. title: How does a CPU work? Boolean algebra
.. slug: how-does-a-cpu-work-boolean-algebra
.. date: 2012-12-23
...tags: draft
.. category: 
.. link: 
.. description: 
.. type: text

= Boolean Algebra and Basic Logic Gates

We are starting (the journey) with four very 
basic logic functions (or operations), which despite their simplicity 
already are valid instructions of a regular CPU:

*AND, OR, XOR and NOT*


Logical functions - also called operations, the author will use both terms interchangebly here -
can be described in various ways, most often it is described implicit
as boolean equation, but it can also be explained explicit in a truth table.

A truth table is a table with the a column for every input and a column for every output.
So it shows the output respective the outputs of the function for all possible combinations of inputs. 
Also they can contain columns with intermedite values.

The truth tables shown in this lesson are in general very small and show only compbinations of two inputs,
although all the functions joining inputs can be expanded to a arbitrary number of inputs.

Boolean equations can be transformed to truth tables and vice versa. Later, we will also introduce 
https://en.wikipedia.org/wiki/Karnaugh_map[Karnaugh maps], a way to optimize boolean logic in a graphical way.

=== NOT 
The not operation also termed as inversion,
is denoted as [overline]#A# = &not; A = Q



[width="50%"]
|==========
| A   | Q    
| 0   | 1    
| 1   | 0    
|=========

image:../images/how_does_cpu/inverter_symbol.svg[width=200]

The not operation is the only one with only one input, it can not be expanded.

Accordingly the gate-level implementation is also known by the name inverter.
Despite its seemingly simple functionality there is a lot to say about the inverter 
for both the logical as well the implementation, so the author will dedicate it an own 
post in the mid-feature.

=== AND

The and  operation  also termed as conjunction 
is denoted as A ∧ B = Q

[width="50%"]
|================
| A   | B   |  Q  
| 0   | 0   |  0  
| 0   | 1   |  0  
| 1   | 0   |  0  
| 1   | 1   |  1  
|================


image:../images/how_does_cpu/and_symbol.svg[width=200]

=== OR 

The or operation also termed as disjunction 
is denoted as A v B = Q

[width="50%"]
|================
| A   | B   |  Q  
| 0   | 0   |  0  
| 0   | 1   |  1 
| 1   | 0   |  1  
| 1   | 1   |  1  
|================
  
image:../images/how_does_cpu/or_symbol.svg[width=200]


=== XOR 

The exclusicve or operation xor which is also termed as antivalence
is denoted as A ⊕ B = Q

[width="50%"]
|================
| A   | B   |  Q  
| 0   | 0   |  0  
| 0   | 1   |  1 
| 1   | 0   |  1  
| 1   | 1   |  0  
|================
  
image:../images/how_does_cpu/xor_symbol.svg[width=200]

There are a lot of important applications for the exclusive-or operation
as you can expect for a such basic and fundamaental operation, but still
the situation is a bit different with this operation compared to 'and' and 'or'.

'''

Although boolean algebra on itself is an interesting field, we will only skim the subject briefly here, just enough
to get a feeling and understanding how to work with boolean formulas.

[NOTE]
If you are interested in a more profound view, providing induction and proof, 
I refer you to accordingly literature (sources listed at the end).


The laws of the boolean algebra are shown in the following table:
[width="100%",cols="4^,100a,100a",options="header"]
|====================================================================================================================
|      |  ∧  (conjunction, AND operator)               |  ∨ (disjunction, OR operator)
| commutative law   | 
["latex", "../images/commut_A.svg",imgfmt="svg"] 
$p \land q = q \land p                                                      $   |
["latex", "../images/commut_V.svg",imgfmt="svg"] 
$p \lor q = q \lor p                                                        $  
| associative law   | 
["latex", "../images/assoc_A.svg",imgfmt="svg"] 
$p \land (q \land r) = (p \land q) \land r = pqr                $  |
["latex", "../images/assoc_V.svg",imgfmt="svg"] 
$p \lor (q \lor r) = (p \lor q) \lor r = p \lor q \lor r        $
| absorptions law   | 
["latex", "../images/absorp_A.svg",imgfmt="svg"] 
$p \land (p \lor q) = p                                         $
| 
["latex", "../images/absorp_V.svg",imgfmt="svg"] 
$p \lor (p \land q) = p                                         $
| distributive law  | 
["latex", "../images/distrib_A.svg",imgfmt="svg"] 
$p \lor (q \lor r) = (p \land q) \lor (p \land r) = pq \lor pr  $ |
["latex", "../images/distrib_V.svg",imgfmt="svg"]
$p \lor (q \lor r) = (p \lor q) \lor (p \lor r) = (p \lor q)(p \lor r)$
| neutral elements  |
["latex", "../images/neutral_A.svg",imgfmt="svg"]
$p \land 1 = p                                                  $ | 
["latex", "../images/neutral_V.svg",imgfmt="svg"]
$p \lor 0 = p                                                   $
| complem. element  | 
["latex", "../images/comp_A.svg",imgfmt="svg"]
$p \land \neg p = 0                                             $ |
["latex", "../images/comp_V.svg",imgfmt="svg"]
$p \lor \neg p = 1                                              $                                      
4+|    Source:  Hans-Jochen Bartsch, Taschenbuch Mathematischer Formeln, 20. Auflage, p. 27- 28  |
|====================================================================================================================


You probably know intuitively - or from school-  the first two laws mentioned in the table, 
the commutative law and the associative laws.
As you can see, every law can be applied to conjunctions as well as disjunctions without any exceptions.

The commutative law implies that the order of the variables is neutral for the operation and can be swapped without
changing the result of the operation. 

The associative law implies, that parenthesis are swappable. Conjunctions can be condensed without operator.

The absorptions law is probably not known to you from school, as it is only used in logic and has no counterpart in at least
school mathmatics.

The distributive law, again, is known from school. It implies that variables / operations outside of paranthesis needs 
to be applied to all variables in the parenthesis.

The law of neutral elements, again is something special to boolean algebra. The logic one is the correspondent to 'true',
and so p and true equals 'true', so as the logic zero is 'false' and so p or false equals p.

The complementary law implies, that to every element (variable) p there is a complementary element (variable) [overline]#p#,
so that the conjunction results in a  logical zero while disjunction results in a logical one.

'''

At this point the author has to leap ahead a bit as some practical issues on the electrical level need some thought on their
logic level:
On the implementation level (for an electrical implementation) it is rather uncommon to use AND,OR and NOT directly, instead 
the inverse functions NAND and NOR are used.


=== NAND and NOR

The NAND operation is denoted as [overline]#A ∧ B# = Q
while the NOR operation is denoted as [overline]#A v B# = Q


[width="100%" cols="a,a"]
|======
| NAND | NOR
|image:../images/how_does_cpu/nand_symbol.svg[width=200] |image:../images/how_does_cpu/nor_symbol.svg[width=200]
|======

As you can see, for those two functions the results are exactly the inverse of their respective complement 
(NAND <==> AND,NOR <==> OR), in that sense the author recommends the construction of the respective truth tables 
as an exercise to the reader.



== The De Morgan theorem

In addition to those merely basic axioms introduced above, there is the **De Morgan theorem**,
which we need to easily convert between NAND and NOR. For the sake of simplicity we only show for 
two elements however the theorem is independent from any number of elements / inputs.

["latex", "../images/demorgan_nand.svg",imgfmt="svg"] 
$\overline{p_1 \land p_2} = \overline{p_1} \lor \overline{p_2}$

[width="75%"]
|==========================================================================================
| A   | B   |[overline]#A# | [overline]#B# |  [overline]#AB# | [overline]#A# v [overline]#B#
| 0   | 0   |    1         |     1         |          1       | 1
| 0   | 1   |    1         |     0         |          1       | 1
| 1   | 0   |    0         |     1         |          1       | 1
| 1   | 1   |    0         |     0         |          0       | 0
|===========================================================================================




image:../images/how_does_cpu/de_morgan_nand_equivalence.svg[width=400]


["latex", "../images/demorgan_nor.svg",imgfmt="svg"] 
$\overline{p_1 \lor p_2} = \overline{p_1} \land \overline{p_2}$


[width="75%"]
|==========================================================================================
| A   | B   |[overline]#A# | [overline]#B# |  [overline]#AvB# | [overline]#A# [overline]#B#
| 0   | 0   |    1         |     1         |          1       | 1
| 0   | 1   |    1         |     0         |          0       | 0
| 1   | 0   |    0         |     1         |          0       | 0
| 1   | 1   |    0         |     0         |          0       | 0
|===========================================================================================


image:../images/how_does_cpu/de_morgan_nor_equivalence.svg[width=400]



Now we are finally equipped to continue with the electrical part / description.

== Implementation on electrical level 

Starting with the inverter in this section of the post (lesson?) we will show the underlying implementation of the logic
functions discussed above. We will only get a brief overview though as the number of techniques or combinations on them 
is nearly endless depending on the specific appliance, but in today's circuits it boils all down to CMOS Technology. 
*CMOS* stands for [underline]#C# omplementary [underline]#M# etal [underline]#O# xid [underline]#S# emiconductor a successor of the prior used NMOS Technology,
which had the disadvantage of high power consumption.

==== Inverter

[width="100%" cols="a,a"]
|======
2+| image:../images/how_does_cpu/inverter_symbol.svg[width=200,float="right"]
| NMOS | CMOS
|image:../images/how_does_cpu/inverter_nmos.svg[width=500] | image:../images/how_does_cpu/inverter_cmos.svg[width=500] 
|======

The inverter has two different tasks to fullfill

1. Refreshing the signal (level) the inverters gets from the preceeding circuit 
2. Actually, inverting the signal 

There are also integrated circuits, called buffer or driver, solely dedicated to the first task mentioned, we will discuss that in a later blog post / lesson.
Here we want to focus only on the logical part of inverting the signal, although for that both functions are equal important, thats why they are combined in one 
circuit. 
In the symbol the first task, the refreshing of the signal (level), is indicated by the triangle, while the little circle denotes the actual inverting function.

==== And

[width="100%" cols="^a,^a"]
|======
2+| image:../images/how_does_cpu/and_symbol.svg[width=200,align="center"]
| wired logic | CMOS
|image:../images/how_does_cpu/wire_and.svg[width=500] | image:../images/how_does_cpu/and_cmos.svg[width=500] 
|======


==== Or

[width="100%" cols="^a,^a"]
|======
2+| image:../images/how_does_cpu/or_symbol.svg[width=200,align="center"]
| wired logic | CMOS
|image:../images/how_does_cpu/wire_or.svg[width=500] | image:../images/how_does_cpu/or_cmos.svg[width=500] 
|======




