.. title: How does a CPU work? Boolean algebra
.. slug: how-does-a-cpu-work-boolean-algebra
.. date: 2012-12-23
...tags: draft
.. category: 
.. link: 
.. description: 
.. type: text

= Boolean Algebra and Basic Logic Gates

We are starting (the journey) with four very 
basic logic functions (or operations), which despite their simplicity 
already are valid instructions of a regular CPU:

*AND, OR, XOR and NOT*


Logical functions - also called operations, the author will use both terms interchangebly here -
can be described in various ways, most often it is described implicit
as boolean equation, but it can also be explained explicit in a truth table.

A truth table is a table with the a column for every input and a column for every output.
So it shows the output respective the outputs of the function for all possible combinations of inputs. 
Also they can contain columns with intermedite values.

The truth tables shown in this lesson are in general very small and show only compbinations of two inputs,
although all the functions joining inputs can be expanded to a arbitrary number of inputs.

Boolean equations can be transformed to truth tables and vice versa. Later, we will also introduce 
https://en.wikipedia.org/wiki/Karnaugh_map[Karnaugh maps], a way to optimize boolean logic in a graphical way.

=== NOT 
The not operation also termed as inversion,
is denoted as [overline]#A# = &not; A = Q



[width="50%"]
|==========
| A   | Q    
| 0   | 1    
| 1   | 0    
|=========

image:../images/how_does_cpu/inverter_symbol.svg[width=200]

The not operation is the only one with only one input, it can not be expanded.

Accordingly the gate-level implementation is also known by the name inverter.
Despite its seemingly simple functionality there is a lot to say about the inverter 
for both the logical as well the implementation, so the author will dedicate it an own 
post in the mid-feature.

=== AND

The and  operation  also termed as conjunction 
is denoted as A ∧ B = Q

[width="50%"]
|================
| A   | B   |  Q  
| 0   | 0   |  0  
| 0   | 1   |  0  
| 1   | 0   |  0  
| 1   | 1   |  1  
|================


image:../images/how_does_cpu/and_symbol.svg[width=200]

=== OR 

The or operation also termed as disjunction 
is denoted as A v B = Q

[width="50%"]
|================
| A   | B   |  Q  
| 0   | 0   |  0  
| 0   | 1   |  1 
| 1   | 0   |  1  
| 1   | 1   |  1  
|================
  
image:../images/how_does_cpu/or_symbol.svg[width=200]


=== XOR 

The exclusive-or operation xor which is also termed as antivalence
is denoted as A ⊕ B = Q

[width="50%"]
|================
| A   | B   |  Q  
| 0   | 0   |  0  
| 0   | 1   |  1 
| 1   | 0   |  1  
| 1   | 1   |  0  
|================
  
image:../images/how_does_cpu/xor_symbol.svg[width=200]

There are a lot of important applications for the exclusive-or operation
as you can expect for a such basic and fundamaental operation, but still
the situation is a bit different with this operation compared to 'and' and 'or'.

'''

Although boolean algebra on itself is an interesting field, we will only skim the subject briefly here, just enough
to get a feeling and understanding how to work with boolean formulas.

[NOTE]
If you are interested in a more profound view, providing induction and proof, 
I refer you to accordingly literature (sources listed at the end).


The laws of the boolean algebra are shown in the following table:
[width="100%",cols="4^,100a,100a",options="header"]
|====================================================================================================================
|      |  ∧  (conjunction, AND operator)               |  ∨ (disjunction, OR operator)
| commutative law   | 
["latex", "../images/commut_A.svg",imgfmt="svg"] 
$p \land q = q \land p                                                         $   |
["latex", "../images/commut_V.svg",imgfmt="svg"] 
$p \lor q = q \lor p                                                           $  
| associative law   | 
["latex", "../images/assoc_A.svg",imgfmt="svg"] 
$p \land (q \land r) = (p \land q) \land r = pqr                $  |
["latex", "../images/assoc_V.svg",imgfmt="svg"] 
$p \lor (q \lor r) = (p \lor q) \lor r = p \lor q \lor r        $
| absorptions law   | 
["latex", "../images/absorp_A.svg",imgfmt="svg"] 
$p \land (p \lor q) = p                                         $
| 
["latex", "../images/absorp_V.svg",imgfmt="svg"] 
$p \lor (p \land q) = p                                         $
| distributive law  | 
["latex", "../images/distrib_A.svg",imgfmt="svg"] 
$p \lor (q \lor r) = (p \land q) \lor (p \land r) = pq \lor pr  $ |
["latex", "../images/distrib_V.svg",imgfmt="svg"]
$p \lor (q \lor r) = (p \lor q) \lor (p \lor r) = (p \lor q)(p \lor r)$
| neutral elements  |
["latex", "../images/neutral_A.svg",imgfmt="svg"]
$p \land 1 = p                                                  $ | 
["latex", "../images/neutral_V.svg",imgfmt="svg"]
$p \lor 0 = p                                                   $
| complem. element  | 
["latex", "../images/comp_A.svg",imgfmt="svg"]
$p \land \neg p = 0                                             $ |
["latex", "../images/comp_V.svg",imgfmt="svg"]
$p \lor \neg p = 1                                              $                                      
4+|    Source:  Hans-Jochen Bartsch, Taschenbuch Mathematischer Formeln, 20. Auflage, p. 27- 28  |
|====================================================================================================================


You probably know intuitively - or from school-  the first two laws mentioned in the table, 
the commutative law and the associative laws.
As you can see, every law can be applied to conjunctions as well as disjunctions without any exceptions.

The commutative law implies that the order of the variables is neutral for the operation and can be swapped without
changing the result of the operation. 

The associative law implies, that parenthesis are swappable. Conjunctions can be condensed without operator.

The absorptions law is probably not known to you from school, as it is only used in logic and has no counterpart in at least
school mathmatics.

The distributive law, again, is known from school. It implies that variables / operations outside of paranthesis needs 
to be applied to all variables in the parenthesis.

The law of neutral elements, again is something special to boolean algebra. The logic one is the correspondent to 'true',
and so p and true equals 'true', so as the logic zero is 'false' and so p or false equals p.

The complementary law implies, that to every element (variable) p there is a complementary element (variable) [overline]#p#,
so that the conjunction results in a  logical zero while disjunction results in a logical one.

'''

At this point the author has to leap ahead a bit as some practical issues on the electrical level need some thought on their
logic level:
On the implementation level (for an electrical implementation) it is rather uncommon to use AND,OR and NOT directly, instead 
the inverse functions NAND and NOR are used.


=== NAND and NOR

The NAND operation is denoted as [overline]#A ∧ B# = Q
while the NOR operation is denoted as [overline]#A v B# = Q


[width="100%" cols="a,a"]
|======
| NAND | NOR
|image:../images/how_does_cpu/nand_symbol.svg[width=200] |image:../images/how_does_cpu/nor_symbol.svg[width=200]
|======

As you can see, for those two functions the results are exactly the inverse of their respective complement 
(NAND <==> AND,NOR <==> OR), in that sense the author recommends the construction of the respective truth tables 
as an exercise to the reader.



== The De Morgan theorem

In addition to those merely basic axioms introduced above, there is the **De Morgan theorem**,
which we need to easily convert between NAND and NOR. For the sake of simplicity we only show for 
two elements however the theorem is independent from any number of elements / inputs.

["latex", "../images/demorgan_nand.svg",imgfmt="svg"] 
$\overline{p_1 \land p_2} = \overline{p_1} \lor \overline{p_2}$

[width="75%"]
|==========================================================================================
| A   | B   |[overline]#A# | [overline]#B# |  [overline]#AB# | [overline]#A# v [overline]#B#
| 0   | 0   |    1         |     1         |          1       | 1
| 0   | 1   |    1         |     0         |          1       | 1
| 1   | 0   |    0         |     1         |          1       | 1
| 1   | 1   |    0         |     0         |          0       | 0
|===========================================================================================




image:../images/how_does_cpu/de_morgan_nand_equivalence.svg[width=400]


["latex", "../images/demorgan_nor.svg",imgfmt="svg"] 
$\overline{p_1 \lor p_2} = \overline{p_1} \land \overline{p_2}$


[width="75%"]
|==========================================================================================
| A   | B   |[overline]#A# | [overline]#B# |  [overline]#AvB# | [overline]#A# [overline]#B#
| 0   | 0   |    1         |     1         |          1       | 1
| 0   | 1   |    1         |     0         |          0       | 0
| 1   | 0   |    0         |     1         |          0       | 0
| 1   | 1   |    0         |     0         |          0       | 0
|===========================================================================================


image:../images/how_does_cpu/de_morgan_nor_equivalence.svg[width=400]



Now we are finally equipped to continue with the electrical part / description.

= Implementation on electrical level 

In this section we introduce the transistor as the integral component allowing the implementation of the operations introduced
above. A transistor is a switching element which can be controlled with a control voltage, similar to an electromechanical relay,
where a small current in a coil builds up a magnetic field which moves the armature to close (or open, depending on the construction) 
the contacts of the load circuit.
The type of transistor we want to introduce and use here is a MOSFET (Metal Oxid Semiconductor Field Effect Transistor) - as opposed to classical bipolar transistor.
As the name suggests a MOSFET is a transistor (or semiconductor) where the load currrent can be controlled by the strength of the electrical field, created on the gate input
//https://www.power-and-beyond.com/whats-the-difference-between-mosfet-and-bjt-a-909006/


image:../images/how_does_cpu/mosfet_model.svg[width=500]

The image above sketches the principal structure of a mosfet on the silicon. Source and drain are both connected to an own n-well, in the p dotted substrate,
while the gate in between is isolated by a thin silicon dioxide layer. There is a forth connector 'bulk', leading to the substrate, in discrete MOSFETs connected to the source,
but for now this one is not relevant.
There is a lot of complex physics behind the workings of a MOSFET all we want to know for now, is that when a voltage is applied to the gate, an electrical field is induced, 
which creates a chanel between source and drain and allows electrons to flow from source to drain. The higher the gate voltage the bigger  (wider) the channel, the more electrons 
flowing (until a certain boundary of course). And if the gate voltage is zero, also the channel is non-existent.

image:../images/how_does_cpu/inverter_nmos.svg[width=500]

With the MOSFET element introduced and a single resistor,an element which reduces the current flow, added, we can straight-forward implement an inverter circuit as shown in the image above.
Source is connected to the ground and Drain is connected to the inverter output and also to the voltage source via a high-impedance resitor. Gate is the input of the inverter.
When the voltage is set to low on the gate, the MOSFET does not conduct and so the potential available on the output is sufficient for a logic one.
Whene a voltage is set to the gate,the drain-source path of the MOSFET becomes conductive, the potential available on the output breaks down an drains away via the drain-source path.


[width="100%" cols="a,a"]
|======
| NMOS NAND | NMOS NOR
|image:../images/how_does_cpu/nand_nmos.svg[width=500] | image:../images/how_does_cpu/nor_nmos.svg[width=500] 
|======

Now it becomes clear, why the inverse function of AND and OR on the gate level is simpler than the original function.



////
Starting with the inverter in this section of the post (lesson?) we will show the underlying implementation of the logic
functions discussed above. We will only get a brief overview though as the number of techniques or combinations on them 
is nearly endless depending on the specific appliance, but in today's circuits it boils all down to CMOS Technology. 
*CMOS* stands for [underline]#C# omplementary [underline]#M# etal [underline]#O# xid [underline]#S# emiconductor a successor of the prior used NMOS Technology,
which had the disadvantage of high power consumption.

==== Inverter

[width="100%" cols="a,a"]
|======
2+| image:../images/how_does_cpu/inverter_symbol.svg[width=200,float="right"]
| NMOS | CMOS
|image:../images/how_does_cpu/inverter_nmos.svg[width=500] | image:../images/how_does_cpu/inverter_cmos.svg[width=500] 
|======

The inverter has two different tasks to fullfill

1. Refreshing the signal (level) the inverters gets from the preceeding circuit 
2. Actually, inverting the signal 

There are also integrated circuits, called buffer or driver, solely dedicated to the first task mentioned, we will discuss that in a later blog post / lesson.
Here we want to focus only on the logical part of inverting the signal, although for that both functions are equal important, thats why they are combined in one 
circuit. 
In the symbol the first task, the refreshing of the signal (level), is indicated by the triangle, while the little circle denotes the actual inverting function.

==== And

[width="100%" cols="^a,^a"]
|======
2+| image:../images/how_does_cpu/and_symbol.svg[width=200,align="center"]
| wired logic | CMOS
|image:../images/how_does_cpu/wire_and.svg[width=500] | image:../images/how_does_cpu/and_cmos.svg[width=500] 
|======


==== Or

[width="100%" cols="^a,^a"]
|======
2+| image:../images/how_does_cpu/or_symbol.svg[width=200,align="center"]
| wired logic | CMOS
|image:../images/how_does_cpu/wire_or.svg[width=500] | image:../images/how_does_cpu/or_cmos.svg[width=500] 
|======
////



