<div class="sect1">
<h2 id="_strong_introduction_and_overview_strong"><strong>Introduction and overview</strong></h2>
<div class="sectionbody">
<div class="paragraph"><p><em>Introduction and overview</em></p></div>
<div class="paragraph"><p>Every topic of this course is broken up into two parts:
A part about the mathematical side of digital logic,
ideally almost independent from implementation details
and a more concrete part handling this very details.
In the concrete part we will mostly discuss the implementation
on an electrical layer, though there are still other solutions
possible based on <a href="https://erik-engheim.medium.com/microprocessors-running-on-air-a47a702dd41f">fluid dynamics</a>,
or <a href="https://www.photonics.com/Articles/All-Optical_Logic_Gates_Show_Promise_for_Optical/a63226">https://www.photonics.com/Articles/All-Optical_Logic_Gates_Show_Promise_for_Optical/a63226</a> [optical gates],
most computers and logic gates are still based on electronics and semiconductor technology and this will not
change with <a href="https://www.azom.com/article.aspx?ArticleID=17173">quantum computing</a>, which is mostly tied to / ajunct to
probability theory. However with quantum computing
the fundamentals behind which the author describes here will completly change.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_strong_a_first_look_at_digital_logic_strong"><strong>A first look at digital logic</strong></h2>
<div class="sectionbody">
<div class="paragraph"><p><em>Boolean Algebra, basic logic gates and their implementation</em></p></div>
<div class="paragraph"><p>In this lesson we will discover truth tables, boolean notation and learn about
De Morgan&#8217;s laws.
Also we have a look at the most basic logic gates and why their are usually are not
implemented as such in electronics, having a look at NAND and NOR instead.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_strong_you_have_to_choose_strong"><strong>You have to choose!</strong></h2>
<div class="sectionbody">
<div class="paragraph"><p><em>A complex gatter: XOR</em></p></div>
<div class="paragraph"><p>Another CPU instrucion and as a side-note and preparation for the next topic,
we have a look at the XOR gate. As in the first lesson we&#8217;ll see first the logic
part and then its translation into an electrical implementation.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_strong_01_01_10_strong"><strong>01+01 = 10</strong></h2>
<div class="sectionbody">
<div class="paragraph"><p><em>Binary systems (Part I) and Combinatorial Logic (Part I)</em></p></div>
<div class="paragraph"><p>Here we explain the basic concept of how to count with only two different states at hand.
Also we will learn how to sum up two positive integer values in the binary system, derivate
the logic needed for a full-adder, to dive into the topic of combinatorial logic.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_strong_let_me_look_that_up_strong"><strong>Let me look that up</strong></h2>
<div class="sectionbody">
<div class="paragraph"><p><em>First look into Memory and Look-Up-Tables (LUTs)</em></p></div>
<div class="paragraph"><p>In this lesson we learn, that - in principal - every form of combinatorial logic
can be transformed into <em>software</em> by putting it into memory. In a practical example we will
show how a DDS sine wave generator use a Look-Up-Table (LUT) to replicate the sine.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_strong_there_is_plenty_room_in_the_negative_space_strong"><strong>There is plenty room in the negative space</strong></h2>
<div class="sectionbody">
<div class="paragraph"><p><em>Binary Systems (Part II) signed integer</em></p></div>
<div class="paragraph"><p>Second part about the binary system. In this post we learn one- and two-
complement, endianess and about conversion to hex.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_strong_adding_is_not_all_strong"><strong>Adding is not all</strong></h2>
<div class="sectionbody">
<div class="paragraph"><p><em>Combinatorial Logic (Part II), a simple ALU</em></p></div>
<div class="paragraph"><p>We want close the first series by this second chapter about combinatorial logic.
We will use our new knowledge of the signed integer adding a subtract functionality
to our adder and also extending the adder to a full ALU</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_strong_outline_what_comes_next_strong"><strong>Outline, what comes next</strong></h2>
<div class="sectionbody">
<div class="paragraph"><p><em>From combinatorial to sequential</em></p></div>
<div class="paragraph"><p>In this first course we learned some basics about digital logic. But all these examples
use only static logic, we are still lacking a concept of how to store computed values.
We need to learn the concept of registers and sequential logic.
This will be the main topic of the second post series.</p></div>
</div>
</div>
