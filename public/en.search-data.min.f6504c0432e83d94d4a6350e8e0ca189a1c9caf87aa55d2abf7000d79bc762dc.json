[{"id":0,"href":"/posts/web/27_compiling_kicad_on_debian_bullseye/","title":"Compiling Kicad on Debian Bullseye","section":"Web","content":"With my new hobby, there came the desire to learn to build and design my own PCB. With that in mind, I began to use the\nopen source ecad solution Kicad. Now I became interested in participating in this project, but, to compile the code you\nhave endure a few challenges - you know, collecting the dependencies,installing them, choose the right branch whiche compiles down\nand so on. Here I want to show you my experience with that.\n\nFirst, clone the gitlab repository:\n\n    git clone https://gitlab.com/kicad/code/kicad.git\n    git checkout 8.0\n\nThen, you need to install a couple of dependencies I list them in a hopefully complete list\n\n    sudo apt-get install cmake libgl-dev libglew-dev libcurl4-openssl-dev ngspice xfonts-scalable libocct-data-exchange-dev\n    libocct-draw-dev libocct-foundation-dev libocct-modeling-algorithms-dev libocct-modeling-data-dev libocct-ocaf-dev\n    libocct-visualization-dev protobuf-compiler libprotobuf-dev swig python3 python3-pip libwxgtk3.0-gtk3-dev\n    unixodbc unixodbc-dev libsecret1\n\n\nBut cmake and wxwidgets both are too old under Debian Bullseye,so you need to install them separately...\n\nFor cmake it is straightforward, you clone the repository and build the program from source:\n\n    git clone https://github.com/Kitware/CMake.git\n    cd CMake\n    ./bootstrap \u0026amp;\u0026amp; make \u0026amp;\u0026amp; sudo make install\n\nFor wxwidgets its a bit harder, you clone the repository with:\n\n    git clone https://github.com/wxWidgets/wxWidgets.git\n    git checkout v3.2.4\n    cd wxWidgets/\n    git submodule update --init src/jpeg\n    git submodule update --init src/tiff\n    git submodule update --init src/stc/scintilla\n    git submodule update --init 3rdparty/catch\n    git submodule update --init 3rdparty/nanosvg\n    mkdir buildgtk\n    cd buildgtk/\n    ../configure --with-gtk --prefix=/usr\n    make -j3\n    sudo make install\n\n\n\nNow you are finally ready to build Kicad itself...\n\n    git clone https://gitlab.com/kicad/code/kicad.git\n    git checkout 8.0\n    mkdir -p build/release\n    cmake  -DCMAKE_BUILD_TYPE=RelWithDebInfo -DKICAD_USE_EGL=ON -DKICAD_WAYLAND=OFF  ../../\n    make -j3\n\n"},{"id":1,"href":"/posts/web/26_get_the_nandlab_go_board_ready_on_debian/","title":"FPGA 101: Get the Nandland Go board ready on Debian Bullseye","section":"Web","content":"Hi there, finally this week the https://nandland.com/the-go-board/[nandland go board] I ordered from the developer Russell Merrick a month ago arrived. It took a detour due to some shipping problems, but this is not about that, so. I had to face quite a few obstacles to get this running on my Debian Bullseye. == Serial Connection via USB First of all, to connect to the board via FTDI usb as suggested on Debian Bullseye you have to first add your user to the group \u0026#39;dialout\u0026#39;, this is done like below: su - usermod -aG dialout $user (in my case $user is sven) exit and then reboot the machine. After that connect it again (just to be sure). And then start putty, and enter /dev/ttyUSB1 as the port you want to use (/dev/ttyUSB0 does not work here) and type baudrate 115200 as suggested. Now you can type in chars and digits and they will be send to the device and back. So this works now. == Install Icecube2 Lets get to the next obstacle, the iCEcube2 installer (and the software) needs to have the library libpng12.so.0 in place and as you can find out with file ./iCEcube2setup_Dec_10_2020_2012 this outputs ./iCEcube2setup_Dec_10_2020_2012: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.2.5, not stripped so you know that you need to install that for the i386 architecture.You can do this via: su apt-get install libpng16-16:i386 ln -s /usr/lib/i386-linux-gnu/libpng16.so.16.37.0 libpng12.so.0 Now the software should launch as expected. == License / Network Issues Next you need to get a Node license that is tied to your hostid from Lattice, you find it out via ip addr show and take the string \u0026#39;link/ether\u0026#39; and copy the Physical MAC address (12-digit hexadecimal value) behind (without colons \u0026#39;:\u0026#39;), into the https://www.latticesemi.com/en/Support/Licensing/DiamondAndiCEcube2SoftwareLicensing/iceCube2[license file generator]. Next check the checkbox and click \u0026#39;Generate License\u0026#39;. Submit. You should get an email with the license file \u0026#39;license.dat\u0026#39; attached. Put that into the directory of your software installation. export LM_LICENSE_FILE=~/software/iCEcube2.2020.12/license/license.dat; (Make this persistent by putting it in your bashrc. so you dont have to repeat this every time you start the software). Now we get an error that contains something like: ‘Invalid host. The hostid of this system does not match the hostid (error code -9)’ As turns out, this error only exists, since debian changes the network interface name to something other than \u0026#39;eth0\u0026#39;, but the license server expect it to be at this point they even write it itself on the support page if you enter license issues: ---- \u0026#34;--If you are getting the error ‘Invalid host. The hostid of this system does not match the hostid (error code -9)’, As Lattice tools use the hardcoded Network Interface Name (eth0) and if the active Network Interface name on the system is set to other than eth0, it fails to check the license file and generate the above error. To avoid this you need to rename the active Network Interface Name to eth0 as follows:- 1). Run the following command with root privileges: a). cd /etc/udev/rules.d/ b). vi 70-persistent-net.rules In the 70-persistent-net.rules file you will see a value as: NAME =”"},{"id":2,"href":"/posts/synth/25_build_your_own_modules/","title":"Build your own synthesizer modules","section":"Posts","content":"== Introduction\nHi,\ntoday I want to share with you the basic knowledge of DIYing your own synthesizer modules - those do not need of the eurorack standard although in my case they are.\n\nIf you get started with https://sdiy.info/wiki/Eurorack[eurorack format] or any other modular like synth standard, but especially the eurorack standard - you will be most likely overwhelmed about\nthe sheer number of manufacturers and available. You can have a simple look here on https://www.modulargrid.net/e/modules/browser[ModularGrid].\nYou need a few weeks or even months, spending time reading some test articles on https://www.amazona.de/[Amzona.de] , or visiting Synthesizer Stores like\nhttps://schneidersladen.de/[SchneidersLaden] to get a rough idea of the diversity of the market.\n\n== Why DIY?\nBut why in the world, if you have so many options already available of readily assembled modules to a good price tag, would you choose to get into DYI and build\nmodules for yourself?\nThere can be multiple reasons:\n- DYI is cheaper than readily available modules, although this is quiet https://www.modwiggler.com/forum/viewtopic.php?t=278889\u0026amp;hilit=diy+costs[debatable], since you have big initial costs for tooling and stuff.\n- DYI is interesting because you learn a lot how the modules work, how electronics in general works, and with time you get eventually better in detecting and fixing the errors you make\n\nIs definitely worthwhile if you want to consider a hobby like electronics, and personally I think a modular synthesizer is the best way to get in contact with electronics and audio circuits as a hobby.\n\nNext, we will briefly discuss what tools, components and consumables you need to start with this hobby. Only briefly, since this is discussed in multiple ways and forms in the https://northcoastsynthesis.com/news/tools-for-getting-started-with-sdiy/[internet].\nAlso, I will narrow the scope down to modules,not case and power supply,since this is a whole other topic, and besides you should never build own power supply if you do not know what you are doing. Stay away from the mains!\n\n\n== Equipment\nSo here is the list of tools you will definitely need as a basic set:\n\n* a solder station and solder supplies\n* a DMM or multimeter to measure resistors, voltages and currents\n* a third hand (that eases your process of soldering by means)\n* a side cutter / wire cutter\n* an electronic pliers\n* as solder for THT (through hole, which you should begin with) you should order some lead-free solder with 1mm diameter\n* a good illuminated workplace\n* depending on your workbench a soldering mat, to prevent your bench from being burned!\n\nThese are the absolute essentials (you could theoreticaly miss out the DMM but it wont do you any good, since its cheap and you need it for basic testing)\nAnd,also, I bet, I forgot something.\n\nIf you want to enter the world of smd /smt technology (we want to use / describe only size 0805 here) you would additionally need:\n\n* as solder for smd soldering lead-free solder of diameter 0.3mm\n* tweezers\n* and optional some magnification glasses, but as said those are optional (e.g. I did not needed them yet, since 0805 is relatively big)\n\n\n== Testing your module\nThat is so far for the building part, but you also need some equipment for testing. It makes sense to first test\nthe module in a separate rack with a separate power supply before putting it into your eurorack case and eventually in case of malfunctioning harm other modules.\nHere a small pod makes totally sense https://www.thomann.de/de/4ms_pod32_powered.htm[4ms pod32].\n\nAlso, you need probably some input source for your module like cv, audio or gate signals, use a simple oscillator (cv,audio) or sequencer (gate) for that reason:\nHere https://www.ericasynths.lv/shop/eurorack-modules/by-series/pico-series/pico-vco/[Erica Synth Pico VCO] or\nhttps://www.ericasynths.lv/shop/eurorack-modules/by-series/pico-series/pico-vco2/[Erica Synth Pico VCO2] comes to mind.\n\nAlso, you need some output module, actually you can really start with this kit its an easy amplifier with a built-in speaker\nhttps://www.exploding-shed.com/clacktronics-mini-speaker-kit/100596[CLACKTRONICS - MINI SPEAKER KIT]\n\n== Reverse Polarity protection\nIn this regard I also want to remind you to always use https://www.allaboutcircuits.com/technical-articles/how-to-protect-your-circuits-using-only-a-diode/[reverse polarity protection diodes] in your builds.\nUse 1N5817 (THT) or MBR0540T1 (smd) for this matter. I could not find a picture so I copied from some befaco schematics so bear with me and ignore the 100nF capacitors.\n\nimage:../reverse_polarity_protection.png[Reverse polarity protection]\n\nWhile this picture might make not sense to you yet, it will as soon as you get learning to read electronics schematics (which you should if you wanna consider this hobby).\n\n\n== Some Manufactures and Modules to start\nLets finally go to the heart of this blog post, which manufactures and modules should you consider as a beginner?\n\nI personally started my journey with the well documented https://www.ericasynths.lv/shop/diy-kits-1/[erica synths edu series], then a few https://shop.befaco.org/183-full-kits[befaco modules] (also well documented,also a bit cheaper over on exploding shed, regarding on shipping\ncosts) and then https://www.nonlinearcircuits.com/modules[modules from NonlinearCircuits (NLC)]  (same well documented), but there is no particular reason to do them in this order.\n\n== Conclusion and links\nIn conclusion the world of eurorack synthesizers and modules is a worthwhile (albeit money-consuming) endeavour, where you should totally go on the bandwagon if you\nhave the need or urge to do so.\n\nLast but not least some links thrown, so you know where to start looking for inspiration and DIY kits:\n\nhttps://www.exploding-shed.com/diy-kits/[exploding shed], a company based in Leipzig Germany\n\nhttps://www.3u-shop.de/[3U Shop], based in Petershagen near Berlin, Germany\n\nhttps://ppvmedien.de/Synthesizer-Klangerzeugung[Synthesizer – So funktioniert elektronische Klangerzeugung by Florian Anwander] The book that brought me into this hobby [German]\n\nhttps://www.modwiggler.com/forum/ucp.php?mode=register[MuffWiggler A very nice synthesizer forum]\n\n= So, spread the sound!\n\n( Still Todo:\nadding some pictures.)"},{"id":3,"href":"/posts/web/ltb162/25_ltb162/","title":"A favorite hobby of mine: Lustiges Taschenbuch Nr. 162","section":"Web","content":"It is about time, to share another favorite of mine with you, and this is duckburg and the duck universe.\nI take the LTB (Lustiges Taschenbuch) Nr. 162 as an example from the golden era of the comic series \u0026#34;Lustiges\nTaschenbuch\u0026#34;\n\nimage:../title.jpg[Title]\n\nimage:../content.jpg[ToC]\n\n== Der goldene Totempfahl (The golden totem pole)\n\nIn the story \u0026#34;Der goldene Totempfahl\u0026#34; english the golden totem pole, uncle scrooge is making a movie about his life,\nthe story plays in the county of Dawson, where they are getting lost after a storm, they meet the indianer \u0026#34;großer Elch\u0026#34;\nenglish \u0026#34;big moose\u0026#34; and are searching for the gold nuggets big moose saved for uncle scrooge back in time.\nThe movie ends with big moose ending as a movie star.\n\n\nimage:../totem_pole.jpg[The golden totem pole]\n\nimage:../totem_pole1.jpg[the golden totem pole]\n\n\n== Der reichste Mann des Universums (The richest men in universe)\n\nIn the story \u0026#34;Der reichest Mann des Universums\u0026#34; (the richest men in universe) uncle scrooge goes on a tour in space with\nhis kins (the nephew Donald Duck and grandnephews Tick, Trick and Track). They become involved in a contest of the richest\nmen in universe with some other guy out in space, who has a wish-machine... Due to uncle scrooge presence,\nthe sensitive balance of the ecosystem gets disturbed... (you have to read the story for yourself ;-) )\n\nimage:../richest_men.jpg[The richest men in universe]\n\nimage:../richest_men1.jpg[the golden totem pole]\n\n"},{"id":4,"href":"/posts/web/24_fpga_beginners_3/","title":"FPGA 101: DE10-nano board: Hello World","section":"Web","content":"Today I want to show you, how to connect to the DE10-nano board, the successor of the DE0-nano board. It is a bit bigger, costs nearly 300 bucks,\nbut also supports Linux out-of-the-box. There is an https://web.archive.org/web/20200815133137/http://angstrom-distribution.org/[Angstrom Linux] installed on the SD-card.\n\nTo connect to the board via the UART interface, power-up the board with the wall-wart,enter the sd-card to start the linux booting, and finally connect the micro-b usb cable (like shown below) with the PC.\n\n\nimage:../de10nano.jpg[DE10-nano]\n\nThen go to the console and enter (as root)\n\n[source, shell]\n----\n# dmesg | grep FTDI\n----\nif the driver ideally is already installed you should get back something like:\n[source, shell]\n----\n[ 6352.585966] usb 3-4: Manufacturer: FTDI\n[ 6352.648922] usbserial: USB Serial support registered for FTDI USB Serial Device\n[ 6352.648961] ftdi_sio 3-4:1.0: FTDI USB Serial Device converter detected\n[ 6352.656051] usb 3-4: FTDI USB Serial Device converter now attached to ttyUSB0\n----\nNow, you only need to change user permissions, again as root (you need to do this after every boot / connection):\n\n[source, shell]\n----\n# chmod a+rw /dev/ttyUSB0\n----\n\nThen, lastly, you need to install putty which on Linux is as simple as on Windows:\n\n[source, shell]\n----\n# apt-get install -y putty\n----\n\nThen open putty\n[source, shell]\n----\n$ putty\n----\n\nenter the device /dev/ttyUSB0, like shown in the ftdi output above, enter the baud-speed of 115200 and then save the configuration.\n\nimage:../putty.png[Putty]\n\nPress \u0026#39;open\u0026#39; and ideally it should connect to the board. If no warning appears,press enter, and you get belows picture:\n\nimage:../angstrom.png[Angstrom]\n\nenter root as login and enter as password.\n\nTo be continued...\n\n\n"},{"id":5,"href":"/posts/web/23_fpga_beginners_2/","title":"FPGA 101: Starting with Quartus and Verilog","section":"Web","content":"So, you decided you want to learn fpga programming and have done the prerequisite from the https://wehrend.uber.space/posts/web/21_fpga_beginners/[introduction 0] as well as done the https://wehrend.uber.space/posts/web/23_fpga_beginners_1/[simple logic circuit] via quartus\u0026#39;s bdf files. Today we want to show you how to figure out Quartus by doing another hardware equivalent of the hello-World program used in the software world - we do program a binary counter showing of by the LED array we have available on our DE0-nano board. For this we will make use of both the Block Diagram Files (bdf) from Quartus and the popular HDL (Hardware Description Language) Verilog. So we simply start by opening Quartus via the desktop-icon. Then we go to menu File \u0026gt;\u0026gt; New Project wizard as shown below, and click it. Then we give it the name counter, we quickly click through the steps of the wizard, there is no more action to do, just click ok until the end of the wizard. During this tutorial we will create the following files: - binarycounter.v - The verilog module with the binary counter - clock_divider.v - A clock divider to slow the system clock to a low frequency the eye still can follow - counter.bdf - A quartus schematic file to tie both above modules and connect it to the pins We start with the binary counter. == Binary counter in Verilog First we define the module, giving it a name as well the in(s) and out(s) it is carrying as parameters. For now this is very simple: We have clk which is shortly for clock as input, and one output called out. [source,verilog] ---- module bin_counter(clk, out); ---- Next we define the input(s) and outputs respectively, the clock will be defined as input from a wire, since it is going into the module and only one single signal that can get high or low. For the output we will define a register - its defined by the keyword reg - to store the values, followed by square-brackets, to define that the output is an array of 8 bits, [0:7] means we have 8 bits, starting from index 0, ending at index 7. [source,verilog] ---- module bin_counter(clk, out); input wire clk; output reg [0:7] out; ---- Then we define the essential module, by specifing what happens between the begin and the end statement, before we use the keyword always followed by an \u0026#39;@\u0026#39; and the sensitivity list in paranthesis. The sensitivity list list\u0026#39;s the clock with podsedge, meaning it reacts on transitions from low (0) to high (1). In between begin and end we simply increment the counter of the out signal. [source,verilog] ---- module bin_counter(clk, out); input wire clk; output reg [0:7] out; always @ (posedge clk) begin out \u0026lt;= out + 1; end ---- Finally we end the module description via the \u0026#39;endmodule\u0026#39; statement. ./binarycounter.v [source,verilog] ---- module bin_counter(clk, out); input wire clk; output reg [0:7] out; always @ (posedge clk) begin out \u0026lt;= out + 1; end endmodule ---- == Clock divider in Verilog Now we can connect our clock signal from the FPGA board, to our input of our binary counter. But wait - there is a problem: If you have a look into the datasheet or the user manual of the board, you will see, that the external clock on the DE0-nano board has a frequency of 50 Mhz, we need to divide this down to a frequency of around 1Hz, which is 1 cycle per second. For that we need to divide the signal by roughly 50.000.000. To compute how much bit width we need we need to do a little computation: [\u0026#34;latex\u0026#34;,\u0026#34;../images/compute_bitwidth.svg\u0026#34; ,imgfmt=\u0026#34;svg\u0026#34;] \\[50.000.000 = 2^x\\] [\u0026#34;latex\u0026#34;,\u0026#34;../images/compute_bitwidth_2.svg\u0026#34; ,imgfmt=\u0026#34;svg\u0026#34;] \\[x = log_{2}(50.000.000)= 25.575\\] So, because we need to round up the result we need a bit-width of 26 bits. with that we would have a frequency of (50MHz / 2^26) = 0.745 Hz as the result. That is less than 1 Hz , but for now we can live with that. What now follows is the simple implementation of the counter: ./clock_divider.v [source,verilog] ---- module clock_divider(clk,out); input wire clk; output reg [0:25] out = 0; always @ (posedge clk) begin out \u0026lt;= out + 1; end endmodule ---- == Counter BDF Lastly we create the counter.bdf file, that ties all together a shown below. First we have to open the file binarycounter.v and clicking _File \u0026gt;\u0026gt; Create / Update \u0026gt;\u0026gt; Create Symbol Files for Current File_ like shown in the image below. image:../quartus_create_symbol_files.png[Quartus - Symbol Files] We open the file / tab clock_divider.v and repeat the step above. After that step we find the just newly created files in the Symbol Library, open the symbol library (see picture below) image:../quartus_symbol_tool.png[Quartus - Symbol Tool] and you find the modules under directory project. image:../quartus_library_window.png[Quartus - Library Window] image:../quartus_counter_bdf_wo_pins.png[Quartus - Counter.bdf] Next, follow the different buildsteps throughout the schematic file: image:../quartus_counter_schematic_0.png[Quartus - Counter.bdf 0] image:../quartus_counter_schematic_1.png[Quartus - Counter.bdf 1] image:../quartus_counter_schematic_2.png[Quartus - Counter.bdf 2] When under properties assigning the bus width, be aware that the syntax is \u0026#39;..\u0026#39; instead of \u0026#39;:\u0026#39; (semicolon) !! image:../quartus_counter_schematic_3.png[Quartus - Counter.bdf 3] image:../quartus_counter_schematic_4.png[Quartus - Counter.bdf 4] image:../quartus_counter_schematic_5.png[Quartus - Counter.bdf 5] image:../quartus_counter_schematic_6.png[Quartus - Counter.bdf 6] image:../quartus_counter_schematic_7.png[Quartus - Counter.bdf 7] == Pin assignment Next we need to link the design inputs and outputs to the physical pins. Below the picture of the clock pin. Do not forget to run the synthesis or at least the analysis before. image:../de0nano_clock.png[DE0-nano Clock] And the picture of the LED outputs. image:../de0nano_output.png[DE0-nano Output] And here the image of the pin planner So for the DE0-nano board we need to assign the pins as follows: - clock50 | PIN_R8 - led1| PIN_A15 - led2| PIN_A13 - led3| PIN_B13 - led4| PIN_A11 - led5| PIN_D1 - led6| PIN_F3 - led7| PIN_B1 - led8| PIN_L3 image:../quartus_pin_planner_counter.png[Quartus - Pin Planner counter] == Programming the device So now we are done with all the work, we can do full synthesis and program our board. Go to _Tools \u0026gt;\u0026gt; Programmer_ or simply click on the programmer icon, and connect your lovely FPGA board to the computer via usb. The hardware should be detected displayed, as well as the sof software file chosen. image:../quartus_programmer_counter.png[Quartus - Programmer Counter] Finally, you should see the leds on the board counting with a frequency of 0.745 Hz. Here as well are the project files link:../counter.tar.gz[Counter project files] Disclaimer: I have stolen this tutorial from https://siytek.com/verilog-quartus/[here] but given it my own images and style. "},{"id":6,"href":"/posts/web/22_fpga_beginners_1/","title":"FPGA 101: Starting with Quartus","section":"Web","content":"So, you decided you want to learn fpga programming and have done the prerequisite from the https://wehrend.uber.space/posts/web/21_fpga_beginners/[last blog post].\nToday we want to show you how to figure out Quartus by doing a hardware equivalent of the hello-World program used in the software world - we call it AndGate\nbecause it is simply that - an and gate feed by to push-buttons as input and a status-LED as output. This way we will make use of the Block Diagram Files (bdf) from Quartus.\n\nSo we simply start by opening Quartus via the desktop-icon. Then we go to menu File \u0026gt;\u0026gt; New Project wizard as shown below, and click it.\n\nI have stolen this tutorial from https://siytek.com/quartus-hello-world/#Setup-the-project[here] but given it my own images and style.\n\nimage:../quartus_menu_new_project.png[Quartus - New Project Wizard]\n\n== Setup the project\n\nNext we see an introduction window as shown below. We click next to get to the next window where we name the Project.\n\nimage:../quartus_introduction.png[Quartus - New Project Wizard]\n\nGive it a proper AndGate or HelloWorld, as you like...\n\nimage:../quartus_project_naming.png[Quartus - Project Naming]\n\nNext  on the page \u0026#39;Project Type\u0026#39; we select \u0026#39;Empty Project\u0026#39;\n\nimage:../quartus_empty_project.png[Quartus - Project Empty]\n\nWe skip the next page \u0026#39;Add files\u0026#39; and go to \u0026#39;Family, Device and Board Settings\u0026#39;.\n\nimage:../quartus_choose_device.png[Quartus - Choose Device]\n\nHere we select the Family Cyclone IV E and select the device with the name\n\u0026#39;EP4CE22F17C6\u0026#39; according to the accompanied data sheet of the DE0-nano board.\nWe click next and for now skip the step \u0026#39;EDA Tool Settings\u0026#39;.\nFinally, we get to the Summary of the project wizard.\n\nimage:../quartus_project_summary.png[Quartus - Project Summary]\n\nAfter you confirmed all is as it should be, click on \u0026#39;Finish\u0026#39; to end the project wizard.\n\n== Building the logic\n\nAs described above we will use the staple features of Quartus to build our own logic in a graphical way without any HDL (Hardware Description) like VHDL or Verilog.\n\nA tab AndGate.bdf appears with a blank canvas where we can \u0026#39;draw\u0026#39; our circuit /logic gates.\nIf we want, we can save our current state by going to File \u0026gt;\u0026gt; save as ... and give a name andGate.bdf and a suitable path.\n\nimage:../quartus_bdf_canvas.png[Quartus - BDF canvas]\n\nNow click on the symbol tool icon as shown in the image below, to open the symbol library.\n\nimage:../quartus_symbol_tool.png[Quartus - Symbol Tool]\n\nA new window opens, showing the library with the three main folders \u0026#39;Megafunction\u0026#39;,\u0026#39;other\u0026#39; and primitives...\n\nimage:../quartus_symbol_library.png[Quartus - Symbol Library]\n\nWe are looking for and gate with two inputs, so go to \u0026#39;Primitives\u0026#39;, \u0026#39;logic\u0026#39;, \u0026#39;and2\u0026#39;, confirm with \u0026#39;ok\u0026#39;...\n\nimage:../quartus_symbol_library_ii.png[Quartus - Symbol Library II]\n\nNow click in the middle of the grid canvas to enter the symbol, then click esc to exit the library modus.\n\nimage:../quartus_and_gate_0.png[Quartus - And gate 0]\n\n== Adding pins\n\nNext we will add some pins to the design file. Those pins define the interface between our design and the physical I/O pins.\nLater in the pin assignment we will link the pins to the physical pins of the device.\n\nThe pin tool icon is right next to the symbol tool icon. Click on the arrow to open the selection menu.\n\nimage:../quartus_pin_tool.png[Quartus - Pin tool]\n\nSelect output and drop the icon down somewhere next to the output of the and gate. Then draw a wire between the gate output and the pin\nby starting from either point, holding down the mouse and drawing a wire to the other point. Then we have a connection.\n\nimage:../quartus_link_output.png[Quartus - Link output]\n\nNow, lets do the same thing equivalent for the input pins...\n\nimage:../quartus_logic_circuit.png[Quartus - Logic circuit]\n\nLastly we will rename the pins to a more suitable name. Double click on the pin, and rename it.\nAnother way is to click on it and in the context menu chosing properties.\nWe rename the inputs to \u0026#39;in1\u0026#39;,\u0026#39;in2\u0026#39; and the output to \u0026#39;out1\u0026#39;, so that we find the pins correctly named in the pin assigner tool\nlater on.\n\nimage:../quartus_logic_circuit_ii.png[Quartus - Logic circuit II]\n\n== Physical Pins / Pin Assignment\n\nTo check out the I/O pins we need, lets check out the user manual of the DE0-nano board.\n\nimage:../de0nano_input.png[Quartus - DE0-nano input]\n\nHere - in above picture - we see the two pushbuttons of the nano board,which are buffered via the SN74AUC17 to do debouncing.\n\nAnd in below we see an (overly simplified) schematic of the  LEDs in the output, missing the pre-resistors.\n\nimage:../de0nano_output.png[Quartus - DE0-nano output]\n\nNow we have all the physical pins that we need together:\n\n- pin E1 - first push-button\n- pin J15 - second push-button\n- pin A15 - status LED\n\nNow to link the design with the physical pins, in Quartus we are going to use the tool __Pin Planner__.\n\nThis tool provides us with a map of available pins and functions and allows us to map parts of the design to the desired pins.\n\nIn order for Quartus to understand which parts of our design can be mapped, we first need to run a partial compilation on the design called __analysis and elaboration__.\n\n== Analysis and elaboration\nThere are different stages of processing required to convert our design into something that can be loaded on to the FPGA.\n\n- Analysis – in this part of the process Quartus checks the design for any errors such as syntax or semantic error.\n- Elaboration – in the first stage of compilation, Quartus maps out the design in RTL blocks. These are the building blocks within the FPGA that perform basic functions such as memory storage, logic gates and registers.\n- Synthesis – in the final stage of compilation, Quartus synthesizes a design at the logic level, converting the RTL design into a gate level design.\n\nIn order to get our pins to appear in the pin planner we could run a full compilation. However this is not necessary as we only need to run the analysis and elaboration stage.\n\nQuartus gives us three compilation tools that allow us to run different levels of compilation.\nWe will do a closer look at these steps and what they do in a future blog post.\nAs the full compilation can take some time it makes sense to only run the necessary process. Go ahead and run analysis and elaboration using the tool found in the menu bar at the top of the screen.\n\nimage:../quartus_analysis_and_elaboration.png[Quartus - Analysis \u0026amp; Elaboration]\n\n\n== Pin assignment\nOnce the process has completed you will have a compilation report and the analysis and elaboration process in the left-hand menu will have a green tick next to it.\n\nNow we can open the pin planner by clicking assignments \u0026gt; pin planner from the menu at the top of the screen.\n\nThe pin planner is a little complex at first glance, but it is fairly easy to use.\n\nYou will see a map of the FPGA with all of the physical pins and their functions.\n\nimage:../quartus_pin_planner_after_run.png[Quartus - Pin Planner]\n\nWe are interested in the list of pins at the bottom. If you have successfully completed the previous step you should see the pins listed. Go ahead and enter your switch and LED pins in the location box.\n\nimage:../quartus_pin_planner_pins_assigned.png[Quartus - Pin Planner - pins assigned]\n\nThe input pins should correspond to the physical pins you have connected to the push buttons and the output pin should correspond to the output pin with the LED connected. Once you are done you can close the pin planner.\n\nYou should notice that Quartus has labelled the pins with the physical outputs that we have just assigned. Note that I have detached the design window to allow a larger work area.\n\nYou can detach a window by right clicking the tab at the top of the work area and selecting detach. You can also attach and detach windows from the window menu on the top menu bar.\n\nimage:../quartus_pins_assigned.png[Quartus - Pins assigned]\n\n\n== Hardware Compilation / Synthesis\n\nNow after we have our pins assigned we can run the compilation process in the hardware world called synthesis, by which the design will be transformed\nto a binary SRAM object file (sof). Meaning its only running in the volatile Static RAM not persisted and be gone after power supply is down.\n\nimage:../quartus_synthesis.png[Quartus - Synthesis]\n\n== Programming\n\nAfter the synthesis has completed we can run the programmer to load this compiled program ino our FPGA.\nWe can open the programmer via __Tools \u0026gt;\u0026gt; Programmer__ or via the icon shown below\n\nimage:../quartus_programmer.png[Quartus - Programmer]\n\nOnce you\u0026#39;ve connected the Nano board with the usb cable, in the programmer click on \u0026#39;Hardware Setup\u0026#39;, in the list of the opening window the device should\nshow up as \u0026#39;USB-Blaster\u0026#39; in the list, select it and click ok. Now we need to select Auto-detect to scan the jtag chain, looking for the fpga device EP4CE22.\nAlso make sure you have the sof file generated - if nothing is shown and in doubt - just running all the steps including Timing Analysis by hand.\n\nimage:../quartus_programmer_sof.png[Quartus - Programmer SOF]\n\nIf you have the sof file in place and the hardware showing up just hit the \u0026#39;start\u0026#39; button, then the programmer does it job.\n\nNow the LED should lit up if you press both buttons at the same time.\nBut if we test the hardware we will notice a different behaviour here: We did not check that the datasheet specifies a high level for the push buttons if __not__ pushed,\nso we need to modify the design, for better comparison we also add an or gate and connect it to led 1.\n\nimage:../quartus_circuit_extended.png[Quartus - Extended Circuit]\n\nI leave it open to the reader to figure out how to design the circuit as shown. If not successfull (or to lazy) the bdf file can be found here (link below).\n\nlink:../andGate.bdf[extended Circuit BDF]\n\nAnd do not forget to connect the pin from the or gate output to the dedicated pin of led 1 (PIN_A13), as shown below\n\nimage:../quartus_pin_planner_ii.png[Quartus - Pin Planner II]\n\nRun the synthesis process and program the board and test.\n\nNow, when we test the behaviour, we will see that now it behaves correctly as suggested.\n\n\n\n"},{"id":7,"href":"/posts/web/21_fpga_beginners_0/","title":"FPGA 101: Starting with HDLS","section":"Web","content":"Today I want to start a blog post series about hardware programming. We start with an introduction to hardware programming with the FPGA-board https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English\u0026amp;No=593[DE0 Nano] from former Altera now Intel. You see a picture of the small board below. It seems you can still order this board, but I have not tested. image:../de0nano.jpg[DE-0 nano] We will show how to setup the environment, in the first step we will (show how to) download and install quartus on a Debian distribution, and configure the programmer. In the second step we will install the simulation software Modelsim. == Quartus IDE The installer can be found https://cdrdv2.intel.com/v1/dl/getContent/795187/795211?filename=qinst-lite-linux-23.1std-991.run[here]. After accepting the license agreement the 60Mb big quartus installer will be downloaded. In the shell console cd to Downloads and change the permissions, making it executable, and execute it [source,console] ---- $ cd ~/Downloads $ chmod +x ./qinst-lite-linux-23.1std-991.run $ ./qinst-lite-linux-23.1std-991.run ---- The installer GUI opens and you get to select the according packages. Do select the packages as shown below (on this system its already installed): Please check that you have around 20GB disk space free on the partition where you want to install the software, download size is around 4.4 - 5.0 GB. image:../quartus_installer_selection.png[Quartus installer] Then, click the download. The download and installation takes a bit of time, so get a cup of coffee in between. After installation finished in your console go to the installation - you have it probably installed in your home directory or under /opt - and execute the shell command to start quartus - or simply click on the Desktop icon. [source,console] ---- $ cd intelFPGA_lite/23.1std/quartus/bin/ $ ./quartus ---- image:../quartus_ide.png[Quartus IDE] Now it is time to take the CD from the DE-0 nano board and copy its content on your computer... Or simply download it from https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English\u0026amp;CategoryNo=139\u0026amp;No=593\u0026amp;PartNo=4#contents[here]. (You have to registrate yourself). After copying, open the project my_first_fpga. You see the different code parts in the project view left. This tutorial is in detail documented in the De0-Nano user manual page 40 - page 80 https://github.com/caglasen/FPGA/blob/master/DE0_Nano_User_Manual.pdf[DE0-nano User Manual] To quote the user manual (p.44): Create a design that causes LEDs on the development board to blink at two distinct rates. This design is easy to create and gives you visual feedback that the design works. Of course, you can use your DE0-Nano board to run other designs as well. For the LED design, you will write Verilog HDL code for a simple 32-bit counter, add a phase-locked loop (PLL) megafunction as the clock source, and add a 2-input multiplexer megafunction. When the design is running on the board, you can press an input switch to multiplex the counter bits that drive the output LEDs. image:../my_first_fpga_view.png[First FPGA] The view below shows the quartus block design file (bdf) for the simple project my_first_fpga. Its depicting a PLL Megafunction and (bus) Multiplexer Megafunction which is IP (=Intellectual Property from Altera / Intel). And then there is a verilog file containing our custom counter logic as shown below. image:../my_first_fpga_bdf.png[First FPGA Block Design File] ../simple_counter.v [source,verilog] ---- //It has a single clock input and a 32-bit output port module simple_counter ( CLOCK_50, counter_out ); input CLOCK_50 ; output\t[31:0] counter_out; reg [31:0] counter_out; always @ (posedge CLOCK_50) // on positive clock edge begin counter_out \u0026lt;= #1 counter_out + 1;// increment counter end endmodule // end of module counter ---- And to check the pin assignment,we open Assignments \u0026gt;\u0026gt; Pin Planner image:../quartus_pin_assignment.png[Quartus Pin Assignment] Now we can run the Compiler - which in hardware programming is a bit different from software compilers - but we get to that in another blog post. image:../quartus_compile_report.png[Quartus Compile Report] We can see in the compile report that 1 of 4 PLLs in total is used. Otherwise we use less than 1 percent of resources. Before we can programm the board first we have to configure the usb settings of our distribution, as documented https://www.intel.com/content/www/us/en/support/programmable/support-resources/download/dri-usb-b-lnx.html[here]. According to \u0026#39;Driver Setup on RedHat Linux Enterprise 5 and Above\u0026#39; which is also valid for Debian Buster / Bullseye, as root user we create a new file */etc/udev/rules.d/51-usbblaster.rules* [source,console] ---- # Intel FPGA Download Cable SUBSYSTEM==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;09fb\u0026#34;, ATTR{idProduct}==\u0026#34;6001\u0026#34;, MODE=\u0026#34;0666\u0026#34; SUBSYSTEM==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;09fb\u0026#34;, ATTR{idProduct}==\u0026#34;6002\u0026#34;, MODE=\u0026#34;0666\u0026#34; SUBSYSTEM==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;09fb\u0026#34;, ATTR{idProduct}==\u0026#34;6003\u0026#34;, MODE=\u0026#34;0666\u0026#34; # Intel FPGA Download Cable II SUBSYSTEM==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;09fb\u0026#34;, ATTR{idProduct}==\u0026#34;6010\u0026#34;, MODE=\u0026#34;0666\u0026#34; SUBSYSTEM==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;09fb\u0026#34;, ATTR{idProduct}==\u0026#34;6810\u0026#34;, MODE=\u0026#34;0666\u0026#34; ---- Then we need to exit quartus and restart the computer, plug the usb cable from terasic in and connect it to your board. Then, do the following as described https://www.intel.com/content/www/us/en/support/programmable/support-resources/download/dri-quartus.html[here]. - Start the Quartus® II software. - Choose Programmer from the Tools menu. The Programmer window will open. - Click the Hardware Setup... button to open the Hardware Setup window. - The selected programming hardware is identified as Currently Selected Hardware. Programming hardware that is already set up appears in the Available hardware items window. - Click the Add Hardware button to open the Add Hardware window if the programming hardware you would like to use is not listed in the Available hardware items window. - Select the appropriate programming cable or programming hardware from the Hardware Type list. - Select the appropriate port and baud rate if necessary. - Click OK. - Select the programming hardware you would like to use by choosing it in the Available hardware items list. - Click Close. - Your programming hardware has been set up. (For detailed information about how to program Intel FPGA devices, refer to Quartus II Help.) Now, you can program the board with the given sof (sram object file). As the title sram suggest, this is a volatile programming which is lost after power supply is gone. We are still missing an important piece of software, which is the simulation software modelsim. We show this in the future == Modelsim The download link for Modelsim for quartus is given https://www.intel.com/content/www/us/en/software-kit/750666/modelsim-intel-fpgas-standard-edition-software-version-20-1-1.html[here] . To install Modelsim on a debian system some 32 bit libraries https://gist.github.com/Razer6/cafc172b5cffae189b4ecda06cf6c64f[have to be installed to]. For Ubuntu and Debian the commands are as follows: [source,console] ---- $ sudo dpkg --add-architecture i386 $ sudo apt-get update $ sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32ncurses6 libxft2 libxft2:i386 libxext6 libxext6:i386 ---- Then the downloaded binary needs to be set executable and executed [source,console] ---- $ cd ~/Downloads $ chmod +x ModelSimSetup-20.1.1.720-linux.run $ ./ModelSimSetup-20.1.1.720-linux.run ---- Now it is ready to be used (mostly, we have still to configure things so that it started from quartus.) Next we will do simple circuit with testbench, so the simulator can be tested. The simulator is started by executing qhsim in the binary folder [source,console] ---- $ cd ../intelFPGA/20.1/modelsim_ase/bin $ ./qhsim ---- image:../modelsim.png[Modelsim] To be continued..."},{"id":8,"href":"/posts/web/20_reducing_rare_earth_elements/","title":"Reducing Rare Earth Dependence: The Quest for Alternative Magnetic Materials","section":"Web","content":"=== Introduction\n\nRare earth elements have long been the backbone of high-tech magnets, with metals like neodymium and dysprosium playing\npivotal roles in various industries. However, the scarcity and rising demand for these valuable resources have prompted\nresearchers to seek alternative solutions. In an effort to reduce our reliance on rare earth magnets, scientists are\nexploring innovative materials and alloy combinations.\nAmong the promising contenders is cerium, an abundant and accessible rare earth element, showing potential to replace\nor augment neodymium magnets. In this article, we\u0026#39;ll delve into the groundbreaking research by Thomas Lograsso and his\nteam at the Ames Laboratory of the US Department of Energy.\n\n=== The Rare Earth Challenge\n\nThe increasing demand for rare earth elements, coupled with the limited number of reliable suppliers, has led to\nconcerns over future shortages. Geopolitical factors, including China\u0026#39;s dominance in the rare earth market, have raised\nadditional challenges. To address these issues, researchers have been on a quest to discover alternative materials for\nstrong permanent magnets that could reduce our reliance on neodymium and other rare earth elements.\n\n=== Cerium: A Promising Alternative\n\nResearchers have set their sights on cerium, a rare earth element that is more abundant and economically accessible.\nTo transform cerium into a powerful magnet, the scientists began by exploring paramagnetic materials. These substances\nare weakly attracted to magnetic fields but are not permanently magnetized.\n\nThomas Lograsso explains, \u0026#34;We can essentially rehabilitate such systems and turn them into magnets by adding specific\nmaterials.\u0026#34; This involves starting with alloys or compounds possessing the right properties to become ferromagnetic at\nroom temperature. But which materials fit the bill?\n\n=== Identifying Promising Candidates\n\nTo identify promising candidates, Lograsso and his team employed a computer-based approach. This method allowed them to\npredict the magnetic behavior of a wide range of materials and determine their suitability for solid-state magnets. The\nresults of this approach were promising, revealing the potential to create powerful magnets with materials like\ncerium-cobalt (CeCo₃) by introducing additives such as magnesium. Subsequent experiments validated the theory, proving\nthe transformation of cerium-cobalt into a ferromagnet.\n\nAnother promising candidate identified through this research is CeCo₅, a material that is already a strong ferromagnet.\nHowever, calculations and experiments demonstrated that the addition of copper and iron could further optimize its\nmagnetic properties.\n\n=== A Sustainable and Economic Solution\n\nThese additives could pave the way for cerium-based materials to potentially replace rare earth magnets like neodymium\nand dysprosium. The advantage is that cerium belongs to the rare earth family, making it more readily available and\neasier to source than its counterparts.\n\nLograsso emphasizes, \u0026#34;Being able to replace the highly demanded and scarce rare earth metals makes sense both\neconomically and environmentally.\u0026#34; While the modified cerium-cobalt compounds may not yet match the strength of the\nmost powerful rare earth magnets, they could still provide valuable alternatives for specific applications.\n\n=== Beyond Cerium: Exploring Further Alternatives\n\nThe research doesn\u0026#39;t stop at cerium-based solutions. Lograsso and his team are already experimenting with alternative\nmaterials that do not rely on cerium or other rare earth metals. For instance, they are working with cobalt to magnetize\niron-germanium (Fe₃Ge) and explore the potential for these materials in high-performance applications.\n\nAs we face the challenges of rare earth scarcity and increasing demand, the search for alternative materials is becoming\nmore critical than ever. The groundbreaking work by researchers like Thomas Lograsso and his team offers hope that we\ncan reduce our dependence on rare earth elements, providing more sustainable and accessible solutions for the\ntechnologies that power our modern world.\n\n(Written by chatgpt 3.5, proofread by Sven Wehrend, backed up by the source:\nhttps://www.scinexx.de/news/technik/alternative-magnete-gegen-den-rohstoffmangel/)\n\n\n\n"},{"id":9,"href":"/posts/web/19_rare_earth_elements/","title":"Unlocking the Secrets of Rare Earth Elements: The Remarkable Case of Neodymium","section":"Web","content":"=== Introduction\n\nRare earth elements, often shrouded in mystery, play a crucial role in our modern world. From smartphones\nto electric vehicles, renewable energy technologies, and even defense systems, these elements are the unsung\nheroes that make our daily lives more sustainable, efficient, and connected. In this article, we\u0026#39;ll delve\ninto the fascinating world of rare earth elements, with a focus on the versatile element, neodymium.\n\n=== The Rare Earth Elements: An Overview\n\nRare earth elements (REEs) are a group of seventeen chemical elements that occupy the lanthanide series of the periodic\ntable, along with scandium and yttrium. Despite the name, they are not necessarily rare, but they are typically found in\nlow concentrations, making their extraction and purification challenging and costly.\n\nThe significance of rare earth elements lies in their unique properties, which make them indispensable in various\nhigh-tech applications. These properties include magnetic behavior, luminescence, and catalytic activity, making REEs\nintegral to the development of cutting-edge technologies.\n\n=== Meet Neodymium: A Star Among Rare Earth Elements\n\nNeodymium, with the atomic number 60 and chemical symbol Nd, is one of the standout members of the rare earth family.\nIt has earned its place in the spotlight due to its remarkable magnetic properties. Neodymium magnets, known as NdFeB\nmagnets (neodymium, iron, and boron), are some of the most powerful and commercially significant permanent magnets\navailable. These small but potent magnets are used in a multitude of everyday applications.\n\n=== Applications of Neodymium Magnets\n\n. Electronics: Neodymium magnets are the driving force behind many electronic devices. They are used in hard drives,\n  headphones, and speakers, providing us with the clear and immersive audio experiences we enjoy.\n\n. Electric Vehicles: Electric motors in vehicles are often powered by neodymium magnets. These magnets make electric\n  vehicles more efficient and sustainable by enhancing motor performance while reducing energy consumption.\n\n. Renewable Energy: Wind turbines rely on neodymium magnets to generate electricity efficiently. The lightweight and\n  powerful neodymium magnets allow for smaller, more energy-efficient turbines that harness wind power effectively.\n\n. Medical Devices: Neodymium magnets are used in various medical devices, including MRI machines and dental equipment,\n  due to their strong magnetic properties.\n\n. Green Technologies: Neodymium plays a critical role in the development of green technologies, such as energy-efficient\n  lighting and regenerative braking systems in hybrid and electric cars.\n\n=== The Challenges of Neodymium Production\n\nWhile neodymium is vital for our modern world, its production comes with environmental and geopolitical challenges. The\nmajority of the world\u0026#39;s neodymium supply is sourced from China, which can lead to concerns about supply chain security\nand environmental consequences of mining and processing.\n\nEnvironmental concerns stem from the extraction process, which involves harmful chemicals and waste materials.\nThis calls for more sustainable practices and the development of recycling methods to reduce our dependence on\nnew neodymium mining.\n\n=== Conclusion\n\nRare earth elements, including neodymium, are the unsung heroes that drive our high-tech world. From the screens of our\nsmartphones to the quiet hum of electric vehicles, these elements make our lives more efficient and environmentally\nfriendly. As we continue to rely on neodymium and other rare earth elements, it is essential to explore sustainable\nproduction and recycling methods to ensure their availability for future generations. Neodymium, with its remarkable\nmagnetic properties, stands as a testament to the immense potential of rare earth elements in shaping our modern world.\n\n(Written by chatgpt 3.5, proofread by Sven Wehrend, the author of the website)\n"},{"id":10,"href":"/posts/web/18_op-amps_introduction/","title":"Op-Amps introduction","section":"Web","content":"Today I want to speak about op-amps. These wonderful, but mysterious components, we have heavely often appearing\nin circuit schematica of analog or analog / digital hybrid circuits. We want to demistify these components.\n\nimage:../op-amp.svg[op-amp,width=\u0026#34;400px\u0026#34;]\n\nThere are two basic thumb rules when handling ideal op-amp circuit. (Real-world op-amp circuits are a bit more complicated, but we will discuss this later).\n\n.1. The first thumb rule is that Vout is essentially the difference of the voltage values at the both inputs, multiplied with an arbitrary but high amplification factor A.\n[\u0026#34;latex\u0026#34;, \u0026#34;../op-amp_rule_1.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\[ V_{out} = A (V_{in+} - V_{in-}) = \\] in  short this goes to\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../op-amp_rule_1-5.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\[ V_{in+} = V_{in-}\\]\n\n\n\n\n.2. The second thumb rule is, that there is no input current.\n\n----\n----\n\n=== The non-inverting amplifier\n\nimage:../op-amp-non-inverting.svg[non-inverting op-amp,width=\u0026#34;400px\u0026#34;]\n\nThe non-inverting amplifier is simple and easy to calculate: The Amplification A is the output voltage divided by the input voltage, which can be computed as follows:\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../op-amp_rule_non-inverting.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\[ A = \\frac{U_{out}}{U_{in}} = \\frac{R1 + R2}{R1}=1 + \\frac{R2}{R1}\\]\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../op-amp_rule_non-inverting_0.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\[U_{in}= 5V; R_{1} = 100 k\\Omega; R_{2} = 100 k\\Omega \\]\n\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../op-amp_rule_non-inverting_1.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\[ \\frac{U_{out}}{U_{in}} = 1 + \\frac{R2}{R1}\\]\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../op-amp_rule_non-inverting_1.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\[ U_{out} = ( 1 + \\frac{R2}{R1}) \\cdot U_{in} = ( 1 + \\frac{100k\\Omega}{100k\\Omega}) \\cdot 5V  = (1 + 1) \\cdot 5V = 10V\\]\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../op-amp_rule_non-inverting_1.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\[ A = 2 \\]\n\n\n=== The voltage follower\n\nA special case of the non-inversting amplifier is the voltage follower. A voltage follower also called impedance converter is used to buffer and decouple a stage from its previous stage.\nIt has a low impedance on the input but a high impedance on the output. So this is used so that later stages do not burden previous stages in terms of voltage.\n\nimage:../voltage-follower.svg[voltage-follower,width=\u0026#34;400px\u0026#34;]\n\n\n=== The (inverting) rectifier\n\nAnother small circuit example is the inverting rectifier. It only lets pass the negative half-wave of an alternating sine current.\n(See also: https://shorturl.at/hivAL[here] )\n\nimage:../inverting_rectifier.png[inverting-rectifier,width=\u0026#34;800px\u0026#34;]\n\nimage:../inverting_rectifier_signal.png[inverting-rectifier-signal,width=\u0026#34;800px\u0026#34;]\n\nTo be continued...\n\n"},{"id":11,"href":"/posts/web/17_analog_computers_101/","title":"Analog Computers 101","section":"Web","content":"Today I want to speak about analog computers. In todays times analog computers are leading a shadowy existence,\ncompared to their digital counterparts. But they are wonderous little machines. And that machines I mean\nwordly because there exists analog mechanical computers that are models from the world and used to\nhttps://en.wikipedia.org/wiki/Tide-predicting_machine[compute and predict tides] in certain areas of the world .\nAlso the brain is an enourmous analog computer with a comparatively very small\nenery budget. https://press.princeton.edu/ideas/is-the-human-brain-a-biological-computer[It only takes 12 Watt.]\n12 Watt; that is not even a quarter of the power supply budget of a laptop.\nAnd you can do very heavy lifting with the brain, but back to topic.\nI want to talk mainly about analog electronic computers, during the world war two those were used to compute\nhttps://web.eecs.utk.edu/~bmaclenn/Classes/494-UC/handouts/LNUC-V.pdf[ballistic curves].\nSo analog computers can sum up, multiply, divide, integrate and differentiate like their digital\ncounterparts.\n\n=== Sum up\n\nTo sum up different signals, we can use an https://en.wikipedia.org/wiki/Operational_amplifier[op-amp] in an inverting\nwiring, that just sums up the signals on its inputs. As it is inverting we need a second op-amp to add behind to get\nthe right signal at the end. The same circuit is used  as a mixer circuit for audio signals, from which I also bought\nthe photo.\n\nimage:../sum_up.png[sum up]\n\n=== Multiply\n\nTo create an analog multiplier we are using a trick here, by transforming the input signals into the logarithmic space\nsumming up the result and transforming it back to the linear space. Mathematically speaking we do the following\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/analog_multiplier_equation.svg\u0026#34; ,imgfmt=\u0026#34;svg\u0026#34;]\n\\[c= a*b = alog( \\log(a) + \\log(b))\\]\n\nBelow you can see the according schematic: The first stage at the inputs are both logarithmic amplifiers, you can see the\nfeedbacking diode between output and non-inverting input. Then we see a simple adder circuit ( an inverting amplifier, with a sum-up node before).\nAnd lastly we have an antilogarithmic amplifier, putting the signals back into the linear space.\nBe aware that the output is actually inverted and we need an additional inverting amplifier to correct the resulting signal.\n\nimage:../analog_multiplier.png[analog Multiplier]\n\n\n\nTo be continued..."},{"id":12,"href":"/posts/synth/16_noise_floor/","title":"Eurorack Synthesizer - Noise Floor","section":"Posts","content":"On my mobile setup, the NiftyVCase I have collected my diy modules (with excepition to the Doepfer\nA-124, I had to include for its great sound). It features a kick-drum from erica synths, an even\nVCO, Sampling Modulator, A*B+C and Rampage from Befaco. As well as the Divebomb III for some delay.\nLast but not least a Zlon skew lfo and a BCM086 Diode Ladder High pass filter.\n\n\nimage:../noise_floor.jpg[noise floor]\n\nlink:../noise_floor.m4a[noise floor Audio]\n"},{"id":13,"href":"/posts/synth/15_jam_session/","title":"Eurorack Synthesizer - Jam Session","section":"Posts","content":"This time, we have a convoluted patch, featuring a new member, the random sequencer\nfrom rat-king, which,as the name suggests, delivers nice randomly sequences. Also\nwe have a new mixer module, self-build.\nWe also utilize both VCOs and both LFO modules...\n\nimage:../jam_session.jpg[jam session ]\n\nlink:../jam_session.m4a[jam session Audio]\n"},{"id":14,"href":"/posts/synth/14_another_small_patch/","title":"Eurorack Synthesizer - Another small patch","section":"Posts","content":"So here is another small patch idea for the Doepfer A-100 system,\nthis time featuring the SEM filter from Oberheim, incarnated in the Doepfer\nmodul A-106-5.\nWe also utilize two LFO modules...\n\nimage:../lfo_sem_patch.jpg[LFO SEM Patch ]\n\nlink:../lfo_sem_patch.m4a[LFO SEM Patch Audio]\n\nimage:../lfo_sem_patch2-3.jpg[LFO SEM Patch ]\n\nlink:../lfo_sem_patch2.m4a[LFO SEM Patch Audio 2]\n\nlink:../lfo_sem_patch3.m4a[LFO SEM Patch Audio 3]\n\nTo this day I did not find the right audio recorder,and I am recording with my smartphone,\nso the sound quality is rather bad. I am still searching for the ideal recording hardware.\n"},{"id":15,"href":"/posts/synth/13_another_simple_patch/","title":"Eurorack Synthesizer - Another simple patch","section":"Posts","content":"So here is another simple patch idea for the Doepfer A-100 system,\nthis time featuring the SEM filter from Oberheim, incarnated in the Doepfer\nmodul A-106-5.\nWe also utilize two A-110 oscillator modules (one standard, one basic), and the LFO.\n\nimage:../sem_patch.jpg[SEM Patch ]\n\nlink:../sem_patch.m4a[SEM Patch Audio]\n\nTo this day I did not find the right audio recorder,and I am recording with my smartphone,\nso the sound quality is rather bad. I am still searching for the ideal recording hardware.\n"},{"id":16,"href":"/posts/web/12_caches_and_caching/","title":"Caches and Caching","section":"Web","content":"When you fire up your browser to visit a website, you most probably did not noticed a very important mechanism underlying the browser and working in the background. Caching. Caches are used everywhere to optimize and improve access times and such in consequence the overall performance (of a site). Caching in the browser for example means, that ideally only the portions of the website that changed are loaded from the www. All else was already loaded before and did not change, thus needs no reload. Portions that are no longer up-to-date become invalidated (also known as cache-invalidation) and are loaded anew from the source. There are two types of very different caches in the computer . hardware caches, real physical parts of silicon located near the CPU, . software caches, implemented in the application respectively underlying libraries The type we want to discuss here are the latter ones. There are multiple different caching strategies, see also https://realpython.com/lru-cache-python/#caching-strategies[here], but we want to focus on the Last-recently-Used (LRU) caching strategy here. Python\u0026#39;s library functools provides a decorator @lru_cache for this caching strategy. But before just mindlessly using the decorator @lru_cache you should think about the problem itself, as https://msol.io/blog/tech/youre-probably-wrong-about-caching/[already stated]. Simple example, taken from the https://docs.python.org/3/library/functools.html#functools.lru_cache[python documentation]: [source, python] ---- from functools import lru_cache @lru_cache(maxsize=None) def fib(n): if n \u0026lt; 2: return n return fib(n-1) + fib(n-2) \u0026gt;\u0026gt;\u0026gt; [fib(n) for n in range(16)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610] \u0026gt;\u0026gt;\u0026gt; fib.cache_info() CacheInfo(hits=28, misses=16, maxsize=None, currsize=16) ---- "},{"id":17,"href":"/posts/synth/11_more_patch_ideas/","title":"Eurorack Synthesizer - More patch ideas","section":"Posts","content":"So here is another patch idea for the Doepfer A-100 system.\nThe results of the Doepfer oscillators are pithlily \u0026#34;knarzig-kernige\u0026#34; sounds.\nWe utilize two A-110 oscillator modules (one standard, one basic), a ring-modulator (A-114)\nand a wasp-filter (A-124), together with some utility modules like a sequencer and an LFO.\n\nimage:../pithily_sounds.jpg[pithily ]\n\nlink:../pithily_sounds.m4a[pithily... Audio]\n\n"},{"id":18,"href":"/posts/synth/09_eurorack_modular/","title":"Pocket Operator Modular 400 in eurorack","section":"Posts","content":"So I bought a low cost eurorack case from doepfer and a set of frontpanels plus power adapter\nfor the pocket operator modular 400 from Oddvolt to put the said machine into a eurorack modular\nsystem. I also bought a small, but decent sequencer, since the one from teenage engineering is not\nvery handy to use. I have two further modules on my list, the https://doepfer.de/a119.htm[Doepfer A-119],\nan input module, as well as the https://doepfer.de/a124.htm[Doepfer A-124], a wasp filter, to complete the setup.\n\nimage:../eurorack_modular.jpg[Eurorack Modular...]\n\nlink:../eurorack_modular.mp4[Eurorack Modular... Video]\n"},{"id":19,"href":"/posts/web/10_wishlist/","title":"Topics to write about - Wishlist","section":"Web","content":"This is a small, incomplete list of topics I\u0026#39;d like to write about in the mid- to far future.\n\n- Caches\n- Interrupts\n- Out-of-Order execution\n- RAW, WAR and WAW conflicts\n- Filters (analog and digital)\n- Analog computers\n- neuronal networks\n- the macrobiom"},{"id":20,"href":"/posts/web/08_religion_spirituality/","title":"Religion vs. spirituality - why I prefer the latter","section":"Web","content":"What I have learned about religions and spirituality over the last years and decades boils down to one\nsimple statement: Religion is about right and wrong and old, outdated dogmas, while spirituality\nsimply says \u0026#34;It is how it is\u0026#34;. For spirituality, there is no right or wrong, only the single moment in the present\nin which we dwell. I find this viewpoint quite amazing. From what I found, it leads to a more awakened state.\n"},{"id":21,"href":"/posts/web/07_serial_interfaces/","title":"Why are serial interfaces everywhere - instead of parallel ones","section":"Web","content":"USB, SPI, I²C, Sata - all these interfaces is common that they are serial interfaces. Serial interfaces are todays common.\nBut why is that the case, especially for high-speed communication? it sounds simply counterintuitive: Parallel wires\ncan theoretically send more bits per time than on singular wire can.\nThe answer to that question is complex and multilayered. There are multiple different reasons why\nserial interfaces are preferred over parallel interfaces. Lets start with the obvious ones:\nThe PCB routing of busses of  8, 16, 32 or even 64 bit width gets increasingly complex to route on printed circuits\nboards (PCBs).The second problem, related to this, is that signal slope need to get transmitted at the same time\nfor all parallel lines (wires), which results in a more complex routing since edges in the strip conductor needs to be compensated.\nSimply put the additional logic implemented in chips to convert the serial signal to parallel ones again (deserializer) and vice versa\n(serializer) is much cheaper than the costs of complex routings.\n"},{"id":22,"href":"/pages/overview2/","title":"How does a CPU work 2? Overview","section":"Pages","content":"= How does a CPU work 2 - Table of contents\n\n\n==  *From Combinatorial to Sequential Logic - Introduction*\n_https://wehrend.uber.space/docs/digital_logic_2/10_sequential_logic[Introduction to Sequential Logic]_\n\nWe get from purely conmbinatorial logic circuits wihout any form of memeory to sequential logic circuits with some\ntype of memory (mostly flipflops)\n\n==  *Clocks,Flipflops and registers*\n\n_https://wehrend.uber.space/docs/digital_logic_2/11_clocks_and_registers/[Clocks,flipflops and registers]_\n\nWe make a leap into the area of sequential logic and introduce some concepts vital  for the sequential logics,\nlike clock, flipflops and registers\n\n==  *Automata*\n\n_https://wehrend.uber.space/docs/digital_logic_2/12_automata/[Automata]_\n\nWe introduce the two (three) different automata Mealy, Moore (and Medwedjew). Those can be synchronous or\nasynchronous.\n\n\n==  *CPU Control*\n\n_http://wehrend.uber.space/docs/digital_logic_02/13_cpu_control/[CPU control]_\n\nHere we are dissecting the brain of a CPU, the control unit, which handles and controls all actions\nof a cpu\n\n==  *Programmable Logic*\n\n_http://wehrend.uber.space/docs/digital_logic_02/14_programmable_logic/[Programmable Logic]_\n\nWe introduce the concept of programmable logic for both, combinatorial and sequential logic.\n\n\n==  *Test thoroughly*\n\n_http://wehrend.uber.space/docs/digital_logic_02/15_testable_logic/[Testable Logic]_\n\nEvery embedded circuit or logic needs some infrastructure for testing. Here we introduce\nJTAG and boundary-scan-tests.\n\n\n==  *HDLs*\n\n_VHDL and Verilog_\n\nWe introduce the concept of a Hardware Description Language (HDL) like VHDL and Verilog.\n\n\n= Extra\n\n==  *Register-Transfer-Level*\n\n_Register-Transfer-Level_\n\nIn this lesson we introduce the concept of the register transfer level.\n\n\n\n"},{"id":23,"href":"/posts/synth/06_pocket_operator_modular_400/","title":"The Pocket Operator Modular 400 patch ideas (II)","section":"Posts","content":"image:../plong_plong_plong.jpg[Plong...]\n\nlink:../plong_plong_plong.mp4[Plong... Video]\n\nWith the random module we can sample \u0026amp; hold a signal from the input. Its companionship is the noise module.\nWe feed the saw output to the input of the rand module.\n\nimage:../beep_bleep.jpg[Beep,bleep...]\n\nlink:../beep_bleep.mp4[Beep,bleep... Video]\n\n\u0026#39;\u0026#39;\u0026#39;\n\n. sine output -\u0026gt; speaker right\n. envelope output -\u0026gt; sine key\n. LFO square -\u0026gt; envelope trig\n. LFO square -\u0026gt; sine fm\n\n\nimage:../sweeping_sinus.jpg[Sweeping sinus...]\n\nlink:../sweeping_sinus.mp4[sweeping sinus... Video]\n\nWe can expand the setup by using the sequencer and utilize the filter. Because  the nice\nthing about modular synthesizers is, that the filter can be used not only in signal paths but\nalso in control paths ;-) .\n\n. filter output -\u0026gt; sine control\n. sequencer output -\u0026gt; filter input\n---\n"},{"id":24,"href":"/docs/digital_logic_2/10_sequential_logic/","title":"10_sequential_logic","section":"Digital Logic 2","content":"== Sequential Logic\n\nComplementary to Combinatorial logic, sequential logic contains some type of memory,\nmaking the behaviour state-dependent. We need to feed it a clock signal.\n\nimage:../images/how_does_cpu/sequential_logic.svg[width=50%]\n\n=== Mealy and Moore Automata (synchronous)\nThere are two different types of finite automata in the digital logic.\nThose are:\n\n. The mealy automata, which is dependent on the input and the state\n. The moore automata, which is only dependent on the state\n\nimage:../images/how_does_cpu/mealy_logic.svg[width=50%]\nimage:../images/how_does_cpu/moore_logic.svg[width=50%]\n\n=== Synchronous and Asynchronous sequential Logic\n\nThere are two different types of sequential logic, the synchronous sequential logic\nwith one central clock, as well as the asnychonous logic which has multiple clock\ndomains.\n\nimage:../images/how_does_cpu/sequential_logic2.svg[width=50%]\n\nWhen we add a clock function to our automata shown above the synchronous\nautomata becomes an asynchronous automata."},{"id":25,"href":"/posts/synth/05_pocket_operator_modular_400/","title":"The Pocket Operator Modular 400 patch ideas","section":"Posts","content":"An analog modular synthesizer was ever me dream, last week I fulfilled this dream of mine,\nand ordered the pocket operator modular 400 from the swedish company teenage engineering.\nLike  furniture from the other popular swedish company you first have to build it yourself,\nbefore making any sound with it. This took me around 3 to 4 hours. But it was worth it.\n\n\n\u0026#39;\u0026#39;\u0026#39;\n\nHere are some patch ideas. In the first example we simply mix the outputs of all\n3 oscillators together and control the sine oscillator with the triangle output of\nthe LFO and the pulse width of the square oscillator with the LFO square.\n\n. mixer out -\u0026gt; speaker right\n. sine out -\u0026gt; mixer 3\n. saw out -\u0026gt; mixer 2\n. square out -\u0026gt; mixer 1\n. sine out -\u0026gt; saw fm\n. LFO triangle -\u0026gt; sine control\n. LFO square -\u0026gt; square pwm\n\nimage:../pom400_patch_idea.jpg[POM 400]\n\nlink:../pom400_patch_idea0.mp4[POM 400 Video]\n\n\u0026#39;\u0026#39;\u0026#39;\n\nimage:../patch_idea_song_from_tibet.jpg[Song from Tibet]\n\nlink:../song_from_tibet.mp4[Song from Tibet Video]\n\n\u0026#39;\u0026#39;\u0026#39;\n\nimage:../plong_plong_plong.jpg[Plong...]\n\nlink:../plong_plong_plong.mp4[Plong... Video]\n\n(I apologise for the bad video quality and bad sound quality, the setup\nwill be improved.) The nice thing about modular synthesizer ist that they break\nthe traditional signal path of voltage controlled oscillator (VCO), voltage controlled filter (VCF) and voltage controlled amplifier (VCA),\nand allow for all the creativity to culminate in experimental setups.\n\nWith the random module we can sample \u0026amp; hold a signal from the input. Its companionship is the noise module.\nWe feed the saw output to the input of the rand module.\n\nimage:../beep_bleep.jpg[Beep,bleep...]\n\nlink:../beep_bleep.mp4[Beep,bleep... Video]\n\n\u0026#39;\u0026#39;\u0026#39;\n\n. sine output -\u0026gt; speaker right\n. envelope output -\u0026gt; sine key\n. LFO square -\u0026gt; envelope trig\n. LFO square -\u0026gt; sine fm\n\n\nimage:../sweeping_sinus.jpg[Sweeping sinus...]\n\nlink:../sweeping_sinus.mp4[sweeping sinus... Video]\n\nWe can expand the setup by using the sequencer and utilize the filter. Because  the nice\nthing about modular synthesizers is, that the filter can be used not only in signal paths but\nalso in control paths ;-) .\n\n. filter output -\u0026gt; sine control\n. sequencer output -\u0026gt; filter input\n"},{"id":26,"href":"/posts/web/04_odoo_hacks/","title":"Odoo hacks: Remove Lock-Button from Odoo v12","section":"Web","content":"Today I want to introduce a solution for a usability-problem I had in Odoo recently. In Odoo 12 there is a lock button next to the edit / save button, and you have to click both to (1) unlock the page and (2) make it editable. This should be done in one step, effectively removing the locking mechanism used in the Delivery Orders (class StockPicking) and Manufacturing Orders (class MrpProduction). The solution requires an xml and a javascript-file as well as a dedicated web-controller. The soliution is presented below. image:../odoo_hacks.png[Odoo Hacks] ./static/src/xml/trigger_toggle.xml [source,xml] ---- \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;openerp\u0026gt; \u0026lt;data\u0026gt; \u0026lt;template id=\u0026#34;assets_backend\u0026#34; name=\u0026#34;trigger_toggle assets\u0026#34; inherit_id=\u0026#34;web.assets_backend\u0026#34;\u0026gt; \u0026lt;xpath expr=\u0026#34;.\u0026#34; position=\u0026#34;inside\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/nm_data_stock/static/src/js/trigger_toggle.js\u0026#34;/\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/openerp\u0026gt; ---- The code is pretty self-explanatory. We use the xml file to add the script. Dont forget to add it in the manifest-file. The javascript functions _onEdit and _onSave are functions from the core webclient (to be more precise web.FormController), and we add some simple url-parsing and an ajax-RPC-call to both functions. .static/src/js/trigger_toggle.js [source,js] ---- odoo.define(\u0026#39;nm_data_stock.trigger_toggle\u0026#39;, function(require){ \u0026#39;use strict\u0026#39;; var ajax = require(\u0026#39;web.ajax\u0026#39;) var FormController = require(\u0026#39;web.FormController\u0026#39;); var triggerButton = FormController.include({ _onEdit: function () { // wait for potential pending changes to be saved (done with widgets // allowing to edit in readonly) this.mutex.getUnlockedDef().then(this._setMode.bind(this, \u0026#39;edit\u0026#39;)); const url = new URL(this.$el.context.baseURI) const parsedHash = new URLSearchParams(url.hash.substring(1)) const id = parsedHash.get(\u0026#39;id\u0026#39;) const model = parsedHash.get(\u0026#39;model\u0026#39;) if (model.toString() == \u0026#39;mrp.production\u0026#39; || model.toString() == \u0026#39;stock.picking\u0026#39;) { console.log(\u0026#39;OnEdit \u0026#39;+ id + \u0026#39; \u0026#39;+ model); ajax.jsonRpc(\u0026#39;/web/webclient/trigger_toggle\u0026#39;, \u0026#39;call\u0026#39;, {\u0026#39;id\u0026#39;: id,\u0026#39;model\u0026#39;: model,\u0026#39;button_state\u0026#39;: \u0026#39;edit\u0026#39;} ) } }, _onSave: function (ev) { ev.stopPropagation(); // Prevent x2m lines to be auto-saved var self = this; this._disableButtons(); const url = new URL(this.$el.context.baseURI) const parsedHash = new URLSearchParams(url.hash.substring(1)) const id = parsedHash.get(\u0026#39;id\u0026#39;) const model = parsedHash.get(\u0026#39;model\u0026#39;) if (model.toString() == \u0026#39;mrp.production\u0026#39; || model.toString() == \u0026#39;stock.picking\u0026#39;) { console.log(\u0026#39;OnSave \u0026#39;+ id + \u0026#39; \u0026#39;+ model); ajax.jsonRpc(\u0026#39;/web/webclient/trigger_toggle\u0026#39;, \u0026#39;call\u0026#39;, {\u0026#39;id\u0026#39;: id, \u0026#39;model\u0026#39;: model,\u0026#39;button_state\u0026#39;: \u0026#39;save\u0026#39;} ) } this.saveRecord().always(function () { self._enableButtons(); }); }, }) }) ---- Below is shown the webcontroller as endpoint for the ajax-RPC-call shown above... controllers/main.py [source,python] ---- from odoo import http from odoo import api,fields from urllib import parse class ToggleController(http.Controller): @http.route(\u0026#39;/web/webclient/trigger_toggle\u0026#39;, type=\u0026#39;json\u0026#39;, auth=\u0026#34;none\u0026#34;) def trigger_toggle(self, **kw): id = kw.get(\u0026#39;id\u0026#39;) model = kw.get(\u0026#39;model\u0026#39;) if model and id: print(model) obj = http.request.env[model].browse(int(id)) return obj.sudo().trigger_toggle(kw.get(\u0026#39;button_state\u0026#39;)) ---- Last but not least the implementation in the both classes. models/stock.py [source,python] ---- class StockPicking(models.Model): \u0026#34;\u0026#34;\u0026#34;Inherit class StockPicking from module stock.\u0026#34;\u0026#34;\u0026#34; def trigger_toggle(self, state): if state==\u0026#39;edit\u0026#39;: self.is_locked = False if state==\u0026#39;save\u0026#39;: self.is_locked = True class MrpProduction(models.Model): \u0026#34;\u0026#34;\u0026#34;Inherit class MrpProduction\u0026#34;\u0026#34;\u0026#34; def trigger_toggle(self, state): if state==\u0026#39;edit\u0026#39;: self.is_locked = False if state==\u0026#39;save\u0026#39;: self.is_locked = True ---- "},{"id":27,"href":"/docs/digital_logic_x/x2_cordic/","title":"X2_cordic","section":"Digital Logic X","content":"== The CORDIC algoritm and direct digital synthesis (DDS)\n\nThe CORDIC (which stands for \u0026#34;coordinate rotation digital computer\u0026#34;) algorithm, was developed in 1956 by Jack.E. Volder, to\nreplace the analog resolvers used for missiles navigation by digital computation on digital computer.\nThe algorithm turned out to be very successfull, today it can be found in every pocket calculator, doing\nthe computation of the trigonometrical functions sinus, cosinus and tangens. But the algorithm is not limited to that\nit can also calculate logarithmic and exponential functions, given the needed modifications.\n\nimage:../images/unit_circle.svg[width=40%]\n\n== The CORDIC algorithm\nIn the image below, V0 shows the start vector\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/startvector.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[v_{0}=\\begin{bmatrix}\n0 \\\\\n1\n\\end{bmatrix}\n\\]\nimage:../images/cordic_circle.svg[width=40%]\n\n\n\nwhich we now iterate, by multiplying it with the rotation matrix, given below:\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/vector_rotation.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[v_{i+1}= R_i v_i\\]\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/vector_rotation.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ R_i = \\begin{bmatrix}\ncos(\\theta) \u0026amp; -sin(\\theta) \\\\\nsin(\\theta) \u0026amp; cos(\\theta)\n\\end{bmatrix}\n\\]\nWe use the following two trigonometric identities:\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/trigonometric_identity_cos.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[\ncos(\\theta) = \\frac{1}{\\sqrt{1+tan^2(\\theta)}}\n\\]\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/trigonometric_identity_cos.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[\nsin(\\theta) = \\frac{tan(\\theta)}{\\sqrt{1+tan^2(\\theta)}}\n\\]\n\nthe rotation matrix becomes\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/vector_rotation.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ R_i =   \\frac{1}{\\sqrt{1+tan^2(\\theta)}} \\begin{bmatrix}\n1 \u0026amp; -tan(\\theta) \\\\\ntan(\\theta) \u0026amp; 1\n\\end{bmatrix}\n\\]\n\nThen the rotation vector $v_{i+1}= R_i v_i$ becomes:\n\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/vector_rotation_1.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ \\begin{bmatrix}\nx_{i+1} \\\\\ny_{i+1} \\\\\n\\end{bmatrix} =   \\frac{1}{\\sqrt{1+tan^2(\\theta)}} \\begin{bmatrix}\n1 \u0026amp; -tan(\\theta) \\\\\ntan(\\theta) \u0026amp; 1\n\\end{bmatrix}\\begin{bmatrix}\nx_{i} \\\\\ny_{i} \\\\\n\\end{bmatrix}\n\\]\n\nWe replace the tangens function with a simpler expression, resulting in a bit shift.\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/vector_rotation_2.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ \\begin{bmatrix}\nx_{i+1} \\\\\ny_{i+1} \\\\\n\\end{bmatrix} =  K_{i} \\begin{bmatrix}\n1 \u0026amp; -\\sigma 2^{-i} \\\\\n\\sigma 2^{-i} \u0026amp; 1\n\\end{bmatrix}\\begin{bmatrix}\nx_{i} \\\\\ny_{i} \\\\\n\\end{bmatrix}\n\\]\nwhere\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/vector_rotation_Ki.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ K_{i} =   \\frac{1}{\\sqrt{1+2^{-2i}}} \\]\n\nand $\\sigma_i$ is used to determine the direction of the rotation. If the angle $\\theta_{i}$ is\npositive then $\\sigma{i}$ is +1, otherwise -1.\n\nThe factor Ki can be factored completly for the iterative process.\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/vector_rotation_Kn.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ K(n) =   \\prod_{i=0}^{n-1}K_{i} = \\prod_{i=0}^{n-1} \\frac{1}{\\sqrt{1+2^{-2i}}} \\]\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/vector_rotation_Kn.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ K = lim_{n-\u0026gt; \\infty} K \\approx  0.60725293500888 \\]\n\n\n\n\n\n\nimage:../images/dds_principle.svg[width=75%]\n\n\n\n\n"},{"id":28,"href":"/posts/web/03_separate_form_and_content/","title":"Separating blog and content","section":"Web","content":"As the blog grow bigger and after the move to odoo, I noticed a gap in the workflow,since\na blog and its content itself are different entities, I wanted to handle them as such,\nthat led me to a cleanup of the original source code for blog, where I moved teh content folder\ninto a different repo, called hugo_content, the former repo I called hugo_blog.\n---\n\nIn my case, this means you have to clone the repo hugo_blog first\ngo inside the new directory (cd hugo ), checkout its branch \u0026#39;hugo\u0026#39; and then do a clone of\nthe repo hugo_content.\n"},{"id":29,"href":"/docs/digital_logic_x/x0_multiplication/","title":"X0_multiplication","section":"Digital Logic X","content":"== Multiplication and Divsion\n\nMultiplication operations can be implemented in very\ndifferent ways: Slow, as a serial operation, controlled by a \nmicro program or fast in dedicated hardware. \n\nThe division is a more complex operation, and thus will be discussed\nin another post.\nAlso for multiplication we set the scope to unsigned integer numbers.\n\n\n=== Shift left and shift right\n\nFor multipliers that are powers of two, the operation is very \nsimple and can be implemented via a shift left.\n\n*A shift left by one bit equals a multiplication by 2, as left shift by n\nbits equals a multiplication by 2^n.*\n\n*A shift right is a division by 2, a right shift by n bits\nis a division by 2^n*\n\nimage:../images/arithmetic_shift.svg[width=75%]\n\n=== The multiplication algorithm \nOf course we are not only interested in the special case of base two multipliers, but rather want the multiplication\noperation to work on all numbers we defined above. We begin with a serial multiplication implementation.\n\nTo start with, we analyze the steps of a binary multiplication, which frankly does not differ much \nfrom a multiplication in the decimal system and is even simpler. We multiply 7 times 6 in the binary\nsystem which results in 42.\n\nmultiplicand x multiplier = product\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/multiplication.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ \\begin{aligned}\n0111_2 \\times 0110_2 \\\\\n\\hline 0000   \\\\\n011110 \\\\\n011100 \\\\\n0111000 \\\\\n\\hline 0101010 \\\\\n\\end{aligned} \\]\n\nAs we can see, based on that example, the multiplication operation is a sequence of shifting and addition.\nFrom this, we can now dissect the multiplication operation and derive an algorithm from it.\n\n*For details we refer to the original source: Rechnerentwurf: Rechenwerke, Mikroprogrammierung, RISC by R. Hoffman, third edition, Oldenbourg Verlag.*\n\nWe have a multiplicator of X[n] and a multiplier of Y[m], then the product of the multiplication operation results in P[n+m],\nmeaning the size of the operation, logically, is the addition of both the size of the multiplicator and the multiplier.\n\n=== Booth Algorithm\n\nThe booth algorithm is one of the most efficient algorithm, as said above, it is again a series of shifting and addition.\nBut here the three following rules have to be considered (see https://www.geeksforgeeks.org/computer-organization-booths-algorithm/[here] for reference ):\n1. The multiplicand is subtracted from the partial product upon encountering the first least significant 1 in a string of 1’s in the multiplier\n2. The multiplicand is added to the partial product upon encountering the first 0 (provided that there was a previous ‘1’) in a string of 0’s in the multiplier.\n3. The partial product does not change when the multiplier bit is identical to the previous multiplier bit.\n\nThe booth algorithm applied can be watched https://www.youtube.com/watch?v=1ubyXuXxIWU[here]:\nimage:../images/booth_algorithm.svg[width=65%]\n\n==== Booth hardware implementation and flowchart\nThe booth multiplier, shown below, consist of the registers A,B for the multiplier and multiplicand and Q for the result.\nThe register AC is the accumulator,the bit register BR and the register QR. An extra flipflop Qn+1 is used to check the multiplier.The flowchart is given below.\nimage:../images/booth_hardware.svg[width=65%]\n\nimage:../images/booth_flowchart.svg[width=65%]\n\nInitially the accumulator and the flipflop Qn+1 are cleared, reset to zero.The sequence counter SC ist set to\nthe number of bits n of the multiplier. Then the two bits in Qn and Qn+1 are checked. In case these are 10\nthe multiplicand gets subtracted from the partial product residing in the Accumulator AC. In case they are 01\nthe multiplicand gets additioned to the partial product residing in the Accumulator AC.\nWhen the two bit are the same (00,11) the partial product is unchanged. Since the subtraction and addition\nalternate, an overflow cannot occur. As next step the partial product and the multiplier (plus Qn+1) are\nshifted right. This is an arithmetic shift (ashr) which shifts AC and QR to the right, thus the sign bit in AC is\nunchanged. The sequence counter is decremented and the computational loop gets repeated n times.\nWhen multiplying negative numbers we need to find 2\u0026#39;s complement because it is easier to add instead of doing\na binary subtraction.\n\n\n// === Parallel Multiplication\n\n// KANN Weg\n//[\u0026#34;latex\u0026#34;, \u0026#34;../images/multiplication_1.svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n//\\[P = X \\ast Y = X \\ast Y_{1} + 2^1 \\ast X \\ast Y_{2} + \\cdots + 2^{n-1} \\ast X \\ast Y_{n} \\]\n//\n//We derive this formula to a Horner-Schema as known from math classes:\n//\n//[\u0026#34;latex\u0026#34;, \u0026#34;../images/multiplication_2.svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n//\\[P = \\underbrace{( \\cdots \\underbrace{( \\underbrace{(X \\ast Y_{n})}_{p_1} 2 + X \\ast Y_{n-1})}_{p_2}2 + \\cdots + X \\ast Y_{2})2 + X \\ast Y_{1}}_{p_n}\\]\n//\n//From which follows a recursive equation system\n//\n//[\u0026#34;latex\u0026#34;, \u0026#34;../images/multiplication_3.svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n//\\[ \\begin{aligned}\n//P^0 = 0 \\\\\n//P^1 = 2 \\ast P^0 + X \\ast Y_n \\\\\n//P^2 = 2 \\ast P^2 + X \\ast Y_{n-1} \\\\\n//\\vdots\n//P^n = 2 \\ast P^{n-1} + X \\ast Y_{1}\n//\\end{aligned}\n//\\]\n\n"},{"id":30,"href":"/docs/digital_logic/00_combinatorial_logic/","title":"00_combinatorial_logic","section":"Digital Logic","content":"This course about digital logic is splitted into two big chunks:\n\n1. Combinatorial circuits (without memory elements)\n2. Sequential circuits (with memory elements)\n\nimage:../images/how_does_cpu/digital_logic.svg[width=500px]\n\nWhile combinatorial circuits consists of boolean gates interconnected without feedback function, sequential gates posses \na memory function,which makes them able to progress to another state.\n\nA combinatorial circuit can have _n_ -wide vector of inputs and an _m_ -wide vector \nof outputs.\n\nCombinatorial circuits can be described in different ways: As a formula, a circuit, a truth table or a Karnaugh map. All these descriptions are convertible into each other.\n\nimage:../images/how_does_cpu/transition_scheme.svg[width=500px]\n\nSo lets get started with the fundamental logic gates and boolean algebra in the \nnext post.\n"},{"id":31,"href":"/posts/web/02_moving-to-hugo/","title":"Moving to Hugo","section":"Web","content":"Since one week my blog is build on the static-site-generator https://gohugo.io/[Hugo].\nI wanted to move to Hugo far earlier, due to the wide variety of themes.\nHowever this required the move from Asciidoc to https://asciidoctor.org/[Asciidoctor],\nand I experienced a few problems with the integration of Asciidoctor into my existing workflow. \nAs the approach of rendering the latex-equations in the asciidoc-documents\nno loger worked, I decided to move on to client-based rendering of formulas,\nlike done in https://gohugo.io/Katex[KaTex] and https://www.mathjax.org/[Mathjax].\n\nSo to install Hugo, Asciidoctor and its dependencies without headaches,\nwe again make use of Docker and its huge ecosystem: Sombody already created Docker images for hugo with asciidoctor integrated,\nso we do not need to go thru the sometimes cumbersome setup of Asciidoctor and its dependencies.\n\nWith docker installed, in the shell (for Linux and Mac OS, for Windows the powershell) we do a\n\n----\ndocker pull klakegg/hugo:edge-asciidoctor\n----\n\nwhich pulls an image with the latest Hugo version and Asciidoctor integrated from the Docker-repo klakegg .\n\nWe navigate to the parent-directory of our blog, and run the following command:\n\n----\ndocker run  -it -v $(pwd):/src klakegg/hugo:edge-asciidoctor new site hugo/blog\n----\n\nThis creates the skeleton of our new site, looking like that:\n\n----\nold-blog\nhugo\n └── blog\n    ├── archetypes\n    ├── config.toml\n    ├── content\n    ├── data\n    ├── layouts\n    ├── static\n    └── themes\n----\n\nWe have no theme installed yet, so go to https://themes.gohugo.io/[themes] and select your favorite,\nmine is https://themes.gohugo.io/themes/hugo-book/[Book]. We install it via simple download or via git \n\n----\ncd hugo/themes\ngit clone https://github.com/alex-shpak/hugo-book\n----\n\nand add the line \n----\ntheme = \u0026#34;hugo-book\u0026#34;\n----\nto our config.toml. While we are at it we also add the following policy, necessary since hugo version 0.91, to our config.\n____\n[security]\n  enableInlineShortcodes = false\n  [security.exec]\n    allow = [\u0026#39;^dart-sass-embedded$\u0026#39;, \u0026#39;^go$\u0026#39;, \u0026#39;^npx$\u0026#39;, \u0026#39;^postcss$\u0026#39;, \u0026#39;^asciidoctor$\u0026#39;]\n    osEnv = [\u0026#39;(?i)^(PATH|PATHEXT|APPDATA|TMP|TEMP|TERM)$\u0026#39;]\n____\n\nNow we need to move the content from the old blog to new, we do something similar to this\n----\ncp ../old_blog/pages ../hugo/content/docs\ncp ../old_blog/posts ../hugo/content/posts\ncp ../old_blog/images ../hugo/content/docs/images \n----\n\nNow we need to convert the adoc-headers to the hugo frontmatter format,and also adapt the \nasciidoc syntax to the new.\nTo make our new blog digesting the equations and formulas written in Latex, we need to add the script for KaTex / Mathjax at some \nlayout-file in the theme of our choice: https://katex.org/docs/browser.html[Integrate KaTex]\n\nTo see what we need to change we execue the hugo-server and in the browser head over to the given address\nhttp://localhost:1313\n\n----\ndocker run  -it -v $(pwd):/src -p 1313:1313 swehrend/hugo-ext-asciidoctor:edge-ext-debian server --renderToDisk\n----\nwhich results in something similar to this:\n\nimage:../hugo_server.png[unnamed image]\n\nIf we are satisfied with the result we can deploy our site with an rsync to our webspace, something similar\nto the following command:\n\n----\nrsync -rav public/ wehrend@giclas.uberspace.de:/var/www/virtual/wehrend/html\n----\n\nimage:../new_site.png[unnamed image]\n"},{"id":32,"href":"/docs/digital_logic/07_risc_v/","title":"07_RISC-V","section":"Digital Logic","content":"== Digital design meets computer architecture\n\n= RISC vs CISC and The RISC-V architecture \n\nExisting processor types can be classified by their instruction type set:\nReduced instruction set computer (RISC), Complex instruction set computer (CISC) and hybrid forms.\nWhile mini processors like ARM for embedded systems mostly utilise reduced instruction\nsets,todays workstation and Server Architectures (x86, x86_64) are hybrids of RISC and CISC.\nThe idea of a reduced instruction set is to avoid big complex instructions and multiple different\naddressing modes (as those typically used in x86 architectures).\nAdvantages of a RISC architecture are shorter pipelines which allows faster clocking.\nRISC architectures follow a simple scheme: \u0026#39;Fetch -\u0026gt; Decode -\u0026gt; Fetch Operands -\u0026gt; Execute -\u0026gt; Write Back\u0026#39;\nAlso instructions have a constant length, memory operations are divided from arithmetic operations,\nwhich is known as Load/Store-architecture. RISC-V is an open standard for the instruction set archtitecture (ISA).\nMost of this post is referenced from the popular book Computer Organization and Design (RISC-V) Edition by Hennessey and Patterson.\n    \n== RISC-V Assembler\n\nHere we introduce the RISC-V assembler.\nThe subset shown here is a bit bigger than the one we will implement further down the line.\nFor example also immediate instructions like \u0026#39;addi\u0026#39; are shown, necessay as a way to load constants\ninto registers. The example program shown below, counts from 0 to 10, utilizing a loop.\n\n----\nADDI x2, x0, 1\nADDI x3, x0, 10\n\nloop:\n   ADD x1, x1, x2\n   SW  x1, 4(x0) \n   BNE x3, x1, loop\n   HLT\n\n----\nRegister-type: Instruction [dest. reg] [reg1] [reg2]\n\nLoad / Store-type:  Instruction [dest. reg] [byte offset(reg1)] \n\nBranch-type: Instruction [dest. reg] [reg1] [dest. label]\n\nFor the load / store instructions the reg1 contains the start address while the byte offset\ncontains the size of the value loaded into the register (normaly 4) / respectively written to\nthe memory.\n\nAn overview of the instruction formats of the different types is given below:\n\nimage:../images/how_does_cpu/instruction_types.png[width=\u0026#34;140%\u0026#34;]\n\n\n== A minimal Implementation\nThe minimal working subset of a RISC-V implementation contains the following instructions:\n\n* Arithmetic-logical instructions \u0026#39;add\u0026#39;, \u0026#39;sub\u0026#39;, \u0026#39;and\u0026#39; and \u0026#39;or\u0026#39; [Register-type instructions]\n\n* Memory reference instructions like load word (lw) and store word (sw)  [Store-type instructions]\n\n* Conditional branch instruction(s) like branch-if-equal (beq) [Branch-type instructions]\n\nWe will see how the instruction set architecture choosen, affects performance-related key aspects like\nclock rate and Cycles-per-instruction (CPI).\nWe will also see, that the different instruction types only differ in the later stages of the Fetch-\u0026gt;Decode-\u0026gt; Execute-cycle\n\nFor every instruction the first two steps are identical:\n\n    1. The program counter (PC) points to the  current code that will be executed.The address is sent to the memory to fetch the current instruction from the memory.\n       \n    2. Read two (one for the lw-instruction) registers, the instruction fields contains the register numbers.\n\nFor the next steps the actions depend on the instruction type, but are still utilizing / sharing the same resources.\nFor example the ALU is used by Register-type instruction to compute data, while it is also used by Store-type instructions\nto compute the address, and the Branch-instructions for the equality test.\nOnly after that ALU, the different instruction types really differ.\n\nimage:../images/how_does_cpu/cpu_structure.svg[width=\u0026#34;120%\u0026#34;]\n\nAs we will see the abstract schematic shown below does not explain all cases. \nWe need another schematic extended, showing also the control parts.\n    \nimage:../images/how_does_cpu/cpu_structure_with_control.svg[width=\u0026#34;120%\u0026#34;]\n\n\n\n== The Fetch-Decode-Execute cycle for the different instruction types\n\nWe will start with the common Fetch-Decode-Execute cycle of a common RISC processor,\nand demonstrate the working principle of it for typical instructions.\n\n\nThe full cycle is: Fetch -\u0026gt; Decode -\u0026gt; Fetch Operands -\u0026gt; Execute -\u0026gt; Write Back\n\n[options=\u0026#34;header\u0026#34;]\n|==================\n| Type | example instruction| Fetch | Decode | Fetch Operands | Execute | Write Back\n| Register |add, sub,and,or | fetch instruction, increase PC by 4 | Decode instruction | Fetch operands from registers | Execute calculation in ALU | Write value back to data memory.\n| Store | lw,sw | fetch instruction, increase PC by 4 | Decode instruction | operand | Calculate address | read / write data from / to memory\n| Branch |beq | fetch instruction,set PC to destination address | Decode instruction | Fetch operands from registers |Test for equality (for beq)  | switch multiplexer for address calculation to second adder\n|==================\n\n\n\n=== The instruction part\nTo explain a cpu on this abstract level, we need to introduce some more concepts,\ne.g that an **instruction**, stored in memory, is accessible under a specific address.\nAn **address** in RISC-V standards is a 32 bit long value, pointing to  a certain cell in a memory array.\nThe **program counter (PC)** is a register which points to a certain address in the memory / register file. The program counter is connected to the first address-adder with a contant intger of 4 (the adress offset, 4 * 1 byte = 32 bit). \n\nimage:../images/how_does_cpu/cpu_instruction_part.svg[width=\u0026#34;120%\u0026#34;]\n\nIf the instruction in the memory is an address modifying instruction,\nthe given value will be added by the second address-adder. \nThis way we can generate **jump** instructions. \n\nimage:../images/how_does_cpu/cpu_instruction_path.svg[width=\u0026#34;120%\u0026#34;]\n\n=== The data path \n\nThe data path shows some elements we already are familiar with - the ALU - as well as elments\nwe are not yet familiar with - the memory blocks - on the right the so-called register file \nand on the left the data memory. Both inputs of the ALU are connected to one (different) register.\n\n\nimage:../images/how_does_cpu/cpu_data_path.svg[width=\u0026#34;120%\u0026#34;]\n\n=== The control part\n\nThe control part is the most black-boxed element we see. We know already how the multiplexers work, \nand we see already a feedback line for the branch control. But most of the elements in this abstract view\nremain unknown to the reader. Let us change this by having a closer look into it.\n\nimage:../images/how_does_cpu/cpu_structure_with_control.svg[width=\u0026#34;120%\u0026#34;]\n"},{"id":33,"href":"/docs/digital_logic/06_memory/","title":"06_Memory","section":"Digital Logic","content":"== Memory Organization\nIn this blog post the author will introduce the different\ntypes of semiconductor memory. This is a wide field, \nso the goal here is to focus on the most important ones \nand draw the differences between the different types.\n\n=== The Memory hierarchy \n\nAs in computing all is about performance, we first have a look \nat the memory hierarchy. As you can see in the pyramid below, memory is \nordered in layers. The slowest elements -also the ones with highest \nlatency - are at the bottom of this pyramid, while the fastest ones are \nshown at the apex.\nImagine your desk is the actual CPU, with an open book laying in front of your\neyes. This is the register. Now you read in this book a reference to another book\nin your bookshelf. Your bookshelf is the cache here. The cache itself is again layered.\nLets say L1-cache is the bookshelf in your room, L2-cache the bookshelf in another room\nand L3-cache books stored in a box in the same room. If you now have a reference\nin your current book (the one on your desk), that refers to a book you do not possess, you need to\ngo to the public library. The public library is your RAM. The access times are really high. \nAnd lets say the book you need is also not available there, and they must order it from a library \nin another city. Then you got to the level at the bottom, which is the disk storage unit.\n\nimage:../images/how_does_cpu/memhierarchy.svg[width=\u0026#34;100%\u0026#34;]\n\nAt the bottom is also the low-priced memory (per byte). \nThe higher you go on the hierarchy the costlier the memory becomes.\nIn this article we will expand our knowledge about the RAM. \nCaches are more complex and will eventually be handeled in a future \narticle.\n\n=== RAM and ROM\nThe image below shows the overall organization of a ram circuit,\nRAM stand for random access memory, so it means a memory with arbitrary\naccess. Simply put, you set an address in and get the data which is stored \nunder the given address location out.The schematic given here also holds for\nRead only memory (ROM). Complementary to ROM, which is persistent, RAM \nis volatile. So it needs ongoing power supply,otherwise it loses\nits stored data.\n\nimage:../images/how_does_cpu/ram_schematic.svg[width=\u0026#34;90%\u0026#34;]\n\nAs can be seen the main parts apart from the memory itself\nare column- and row-decoder, as well as read / write amplifier.\nThe address-decoder just consists of well-known combinatorial logic,\nwhile the amplifier are a bit more complex.\nThe blue dots on the intersection of rows and columns mark the\nplacements of the memory cell, depending on the type of memory,\nthose differ and are explained in the next section.\n\n==== The different memory cells\n\n\n[cols=\u0026#34;a,a\u0026#34; width=\u0026#34;100%\u0026#34;]\n|===\n| static RAM (SRAM)  | dynamic RAM (DRAM)\n| image:../images/how_does_cpu/sram_nmos.svg[width=\u0026#34;100%\u0026#34;] \n| image:../images/how_does_cpu/dram.svg[width=\u0026#34;100%\u0026#34;]\n| transistor # 4 | transistor # 1 \n|image:../images/how_does_cpu/sram_cmos.svg[width=\u0026#34;100%\u0026#34;] |\n| transistor # 6 |\n|===\n\n=== SRAM vs. DRAM\n\nThe static RAM (SRAM) cell has the advantage of holding the stored value \nas long as the power supply is not interrupted. Its clear disadvantage\nis the circuit effort of minum 4 transistor (for an nmos design) but regularly 6 \nfor a cmos design.That makes it ideal for small pockets of memories like registers\nand cache located near the cpu.\nComplementary the dynamic RAM (DRAM) cell needs just one transistor and one capacitor \nto hold the stored value, but needs to be refreshed periodically.\n\n\n=== The register file\n\nimage:../images/how_does_cpu/register_file.svg[width=\u0026#34;60%\u0026#34;] \n\nAt this point the author wants to introduce the so-called register\nfile. This is a type of memory which can have multiple read ports.\nwhich is useful as input for the ALU we introduced in the last blog\npost. While the amount of read ports is theoretically unlimited, \nthe amount of write ports is usually one. The reason, as the vivid \nreader can imagine is to mitigate hazards, which is with multiple \nread ports difficult to handle.\n\nimage:../images/how_does_cpu/register_file_read_ports.svg[width=\u0026#34;100%\u0026#34;]\n\nimage:../images/how_does_cpu/register_file_write_port.svg[width=\u0026#34;100%\u0026#34;] \n\n////\n==== The bus cycle\nThe bus cycles are highly specific on the chosen CPU and / or implementation, \nso here we can only show the essentials. \nFor this example to show the fundamentals of read and write\ncycle the author chose the Zilog (R) Z80 processor. We will only have \na look onto the surface here and not discuss things like direct memory access (DMA).\nThe Z80 is a somewhat simple processor, designed 1976.\n\n*Memory pins*\n[cols=\u0026#34;a,a,a\u0026#34;,autowidth,options=\u0026#34;header\u0026#34;]\n|===\n| Pin(s)   | Description         | Comment\n| A0 - An  | Address lines / bus | \n| D0 - Dn  | Data lines / bus    |\n| /CE | Chip Enable (low-active) | Enable the chip; also known as Chip Select (/CS)\n| /OE | Output Enable (low-active) | Enable the data output \n| /WE | Write Enable (low-active) | Enable write cycle \n|===\n\n*Zilog Z80 - overview of memory relevant pins*\n[cols=\u0026#34;a,a,a\u0026#34; autowidth options=\u0026#34;header\u0026#34;]\n|===\n| Pin(s)   | Description         | Comment\n| Clk      | Clock               |\n| /MREQ    | Memory Request (low-active) |\n| A0 - A7  | Address lines / bus | \n| D0 - D7  | Data lines / bus    |\n| /M1      | machine cycle 1 (low-active) | instruction fetch cycle\n| /RD | Read (low-active)  | read operation\n| /WR | Write (low-active) | write operation\n| /RFSH | Refresh (low-active) | Refresh for DRAM\n| /WAIT | Wait (low-active) | use wait-cycles\n|===\n\n\nimage:../images/how_does_cpu/m1_cycle.svg[width=\u0026#34;80%\u0026#34;] \nimage:../images/how_does_cpu/m2m3_cycle.svg[width=\u0026#34;80%\u0026#34;] \n////\n"},{"id":34,"href":"/docs/digital_logic_2/11_clocks_and_registers/","title":"11_Clocks_flipflops_and_registers","section":"Digital Logic 2","content":"== Clocks, Flipflops and registers\nIn this blog post the author will introduce multiple elements needed at a later \nstage.\n\n\n=== Register-Transfer-Level needs a clock source\nAs for now we only learned about combinatiorial logic, which works\nwithout any clock source - every signal is just delayed by the \ntime it needs to travel through the circuit. This is known as asynchronous.\nBut for more sophisticated tasks, sequential circuits, having registers \nstoring the input and output signals are necessary \nto get correct results. This is known as synchronous.\nMost, if not all designs used nowadays are synchronous, \ndue to a lower design complexity.\n\n\n*Register-Transfer-Level*\n\n\nimage:../images/how_does_cpu/rtl_scheme.svg[width=\u0026#34;100%\u0026#34;]\n\nThe blue parts in the image above are showing registers where the values are \nstored, we will see later how those are implemented, lets first have a look \nat the clock source which is needed.\n\nThere are different ways to create a clock source: \n\n. A crystal oscillator\n. A ring oscillator \n\nThe former one is the classical, the later one a more modern variant.\n\n[cols=\u0026#34;a,a\u0026#34; width=\u0026#34;100%\u0026#34;]\n|===\n| *crystal oscillator* | *ring oscillator*\n|image:../images/how_does_cpu/crystal_symbol.svg[width=\u0026#34;80%\u0026#34;]\n|image:../images/how_does_cpu/inverter_chain_symbol.svg[width=\u0026#34;80%\u0026#34;]\n|typical frequence range: 1Mhz..100Mhz | typical frequence range: 1Hz..15Mhz(discrete layout)\n|image:../images/how_does_cpu/pierce_gate_circuit.svg[width=\u0026#34;350px\u0026#34;]\n|image:../images/how_does_cpu/inverter_chain.svg[width=\u0026#34;350px\u0026#34;]\n| frequency determined by crystal geometry \n| frequency determined by propagation delay and number of gates\n| accuracy mostly dependent from temperature; for precise applications crystal ovens are used\n| accuracy mostly dependent from power supply stability \n|===\n\n==== The crystal oscillator\nThe crystal oscilltor is a clock source based on a quartz crystal.\nThe frequency is dependent on the geometry of the quartz.\nCrystal oscillators are available in a metal box housing, with \nadditional wiring, with the quartz being the heart of the circuit. \nThe circuit is commonly based on the https://en.wikipedia.org/wiki/Pierce_oscillator[Pierce oscillator].\n\nimage:../images/how_does_cpu/pierce_gate_circuit.svg[width=\u0026#34;400px\u0026#34;]\n\nTheir accuracy is mostly dependent on the temperature,so for applications with high accuracy needs, \nthey are housed in a quartz oven, holding the quartz on a constant temperature.\nAn interesting teardown of such an oscillator is available on http://www.righto.com/2021/02/teardown-of-quartz-crystal-oscillator.html[Ken Shirriffs blog].\n\n\n==== The ring oscillator\nAnother common source of a clock source is the ring oscillator.\nThe trick here is to chain an odd number of inverter gates and feedback the output of the last inverter as input \nto the first inverter. This way we create an oscillating circuit. \n\nimage:../images/how_does_cpu/inverter_chain.svg[width=\u0026#34;400px\u0026#34;]\n\nThe frequency is dependent on the number of inverters as well as the propagation time Tp (see the equation below). The time the signal needs to travel \ntrough the gate is known as propagation time Tp.\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../images/how_does_cpu/ring_oscillator_frequency.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;40%\u0026#34;] \n\\[f_{ro}  = \\frac{1}{2nT_{p}}\\]\n\nHere the accuracy is mostly dependent on the stability of the power supply.\nAn example where it is used - e.g. the 8087, intels(R) Floating Point Unit - is again provided by\nhttp://www.righto.com/2018/08/inside-die-of-intels-8087-coprocessor.html[Ken Shirriffs blog].\nAs shown there, the frequency can be decreased by adding an RC-network between the inverters.\n\n\n\n==== The classic RS-flipflop\n\nThe classic flipflop consists of two Nand gates which outputs are feedback\u0026#39;ed to the complementary \ngate, as can be seen in the table below. Below the circuit the truth table is given.\nAs can be seen the flipflop locks the output to one state, \u0026#39;1\u0026#39; or \u0026#39;0\u0026#39;. \nIf both inputs are set low, the output is undefined (and conforms to the preferred position).\n\n[cols=\u0026#34;a,a\u0026#34; width=\u0026#34;100%\u0026#34;]\n|===\n| *RS-flipflop structure* | *RS-flipflop symbol*\n|image:../images/how_does_cpu/flipflop_circuit.svg[width=\u0026#34;80%\u0026#34;]\n|image:../images/how_does_cpu/flipflop_symbol.svg[width=\u0026#34;80%\u0026#34;]\n|===\n\n[width=\u0026#34;50%\u0026#34;]\n|===\n|̅R | ̅S || Q | ̅Q | comments\n| 0  | 0  || 1 | 1 | invalid\n| 0  | 1  || 1 | 0 | Reset\n| 1  | 0  || 0 | 1 | Set\n| 1  | 1  || Q | ̅Q | --\n|===\nOne application of the classic RS-flipflop is to debounce switches.\n\nBut for most applications a more evolved flipflop is necessary. Let\u0026#39;s have\na look at the (D)ata-flipflop.\n\n==== The D-flipflop\n\nIn the D-flipflop the circuit of the RS-flipflop is preceeded by two Nand gates,\ncontrolled by a clock impulse. Only when the clock is high (i.e. \u0026#39;1\u0026#39;) the date applied\nto the (D)ata-input is valid and stored in the RS-fliplop. Otherwise the applied data \ninput is invalid.\n\n[cols=\u0026#34;a,a\u0026#34; width=\u0026#34;100%\u0026#34;]\n|===\n| *D-flipflop structure* | *D-flipflop symbol*\n|image:../images/how_does_cpu/dflipflop_circuit.svg[width=\u0026#34;80%\u0026#34;]\n|image:../images/how_does_cpu/dflipflop_symbol.svg[width=\u0026#34;80%\u0026#34;]\n|===\n\n[width=\u0026#34;50%\u0026#34;]\n|===\n|Clock   | D | Q | ̅Q | comments\n| 🠓 \u0026gt;\u0026gt;0  | x  | Q | ̅Q | no change\n| 🠓 \u0026gt;\u0026gt;0  | 1  | 1 | 0 | Reset\n| 🠑 \u0026gt;\u0026gt;1  | 0  | 0 | 1 | Set\n| 🠑 \u0026gt;\u0026gt;1   | 1  | Q | ̅Q | -\n|===\n\n\n=== A binary counter\n\nUsing the D-flipflop we got acquainted with in the last section,\nwe can construct an (asynchronous) binary counter.\nThis output can be used as adresses for a ROM table, as we will see in another blog post.\n\n[cols=\u0026#34;a\u0026#34; width=\u0026#34;100%\u0026#34;]\n|===\n| *Asynchronous binary counter with D-flipflops* \n|image:../images/how_does_cpu/dflipflop_counter.svg[width=\u0026#34;100%\u0026#34;]\n|===\n\nUsing the outputs independent, it can be seen that the counter \nalso works as frequency divider: On every output the frequency\nis divided by two referenced to the previous one.\n\n== Registers\nWhat are registers? Registers are used to hold respectively store values.\nEvery slighlty more complex nowadays CPU has copious quantities of registers inside.\nRegister sizes vary widely dependent on the application. Reaching from status registers \nonly holding one bit to registers over 32 and 64 bit for regular registers until vector \nregisters with a size of 64 bytes (= 512 bits). Those registers are named after a certain\nscheme, in some architectures with numbers (e.g. MIPS and ARM), other times with a more\ncomnplex scheme of alphabetic numbers (like in x86 architectures).\n\n\nimage:../images/how_does_cpu/register.svg[width=\u0026#34;100%\u0026#34;]\n\nIn the previous sections we have learned about the flipflop.\nThese are the building blocks of registers. As can be seen in the picture\nabove every flipflop is clocked by the same signal.\nWe will also often use the term accumulator.\nAccumulators are registers which are source and destination registers\nat the same time. So e.g. on addition they store one input value and\nafter the operation, holding the result in the same register.\n\n"},{"id":35,"href":"/docs/digital_logic/05_alu/","title":"05_ALU","section":"Digital Logic","content":"== The ALU, the swiss knife of every cpu\n\nToday the author wants to introduce an important part of every cpu:\nThe arithmetic logic unit (ALU), we already know about some functions\npresented in the blog posts before. In this post we want to close the\ngaps systematically.\nTime for a short recap: The logic functions \u0026#39;and\u0026#39;,\u0026#39;or\u0026#39;,\u0026#39;not\u0026#39; and \u0026#39;xor\u0026#39;\nwere introduced, also the arithmetic functions \u0026#39;add\u0026#39; and \u0026#39;sub\u0026#39; for integers\nwere shown. Now we want to build most of those functionalities in one unit,\nthe 1-bit alu cell.\n\nimage:../images/how_does_cpu/alu_symbol.svg[width=\u0026#34;100%\u0026#34;]\n\n[width=\u0026#34;50%\u0026#34;,cols=\u0026#34;5,4,2,2,4\u0026#34;,options=\u0026#34;header\u0026#34;]\n|===\n| Function | description | Ainvert | Binvert | Operation\n| and  | a \u0026amp; b | 0 | 0 | 00\n| or |  a \\| b | 0 | 0 | 01\n| add |a + b | 0 | 0 | 10\n| sub |a - b | 0 | 1 | 10\n| slt |a \u0026lt; b | 0 | 1 | 11\n| nor |a nor b | 1 | 1 | 00\n| nand | a nand b | 1 | 1| 01\n|===\n\n\n=== A 1-bit ALU cell \nTo keep things simple we implement an ALU for 1 bit,\nwhich then can be adapted to every bitwidth simply \nby repitition. We introduce an implementation designed\nby Hennessey and Peterson, quoted from the popular book\nComputer Organization and Design (RISC-V) Edition by Hennessey and Patterson.\n\nimage:../images/how_does_cpu/1bit_alu_cell.svg[width=\u0026#34;80%\u0026#34;]\n\nThe implementation will support the fundamental operations \n\u0026#39;and\u0026#39;,\u0026#39;or\u0026#39;, \u0026#39;add\u0026#39; and \u0026#39;sub\u0026#39;. As we already learned the subtraction \ncan be realised two\u0026#39;s complement: Inverting the input B and setting the carry-in to one.\n\n=== Construct an n-bit ALU \n\nThe 1bit ALU-cell we created in the first section, can be chained to an n-bit width-alu.\nThe last ALU-cell in the chain, differs a bit from the regular cell as it also includes\nan overflow-detection circuit. We will get to it later in the article.\n\nimage:../images/how_does_cpu/1bit_alu_cell_with_overflow.svg[width=\u0026#34;80%\u0026#34;]\n\n\nimage:../images/how_does_cpu/alu_array_with_less.svg[width=\u0026#34;60%\u0026#34;]\n////\n// == A 4-bit ALU\n// \n// To keep things simple we show an example of an ALU with a bit\n// width of only 4 bits, and only a few basic instructioins \n// But when the principle is clear it can easily \n// be extended to a wider bit width. (Inspired by \n// http://www.csc.villanova.edu/~mdamian/Past/csc2400fa13/assign/ALU.html[this site])\n// \n// image:../images/how_does_cpu/alu_schematic.svg[width=\u0026#34;100%\u0026#34;]\n// \n// ==== Bitwise AND and OR\n// For the bitwise logical operations we simply put in one gate per\n// bit-slice. So every bit has a dedicated and-gate as well as one or-gate.\n// \n// image:../images/how_does_cpu/and_array.svg[width=\u0026#34;100%\u0026#34;]\n// \n// image:../images/how_does_cpu/or_array.svg[width=\u0026#34;100%\u0026#34;]\n////\n\n\n\n////\n// ==== Addition and Subtraction\n// \n// For the Addition we can decide between a simple ripple-carry-adder (RCA)\n// or some type of carry-look-ahead adder (CLA). To keep it simple we choose\n// the RCA, but be aware that this implementation becomes very slow for high\n// bit widths!\n// \n// image:../images/how_does_cpu/fulladder_cell.svg[width=\u0026#34;60%\u0026#34;]\n// \n// image:../images/how_does_cpu/fulladder_structure.svg[width=\u0026#34;100%\u0026#34;]\n// \n// We\u0026#39;ve also already seen how the subtraction can be implemented.This could \n// also be another dedicated circuit. But as we are smart we use the clever\n// solution of XORs which does the inversion-part, and a carry-input of one for the lowest bit, \n// which does the increment-part of the two\u0026#39;s complement, as we have already seen\n// in one of the posts before. \n////\n\n=== Set-less-than\nWe want the complete ALU to support another fundamental instruction set-less-than (slt), \nnecessary to allow branch-operations later on. For this operation the addional input \u0026#39;less\u0026#39;\nis designed. So the ALU supports an instruction that in C looks like:\n____\n(a \u0026lt; b)?  1 : 0\n____\n \nThis can be simply implemented by subtracting b  from a, and testing if the value is less than zero.\nIn the implementation, every alu-cell in the chain but the least-significant-bit, gets a zero on the \u0026#39;less\u0026#39; input.\nThe first alu-cell gets the result of the last one, which is representing the most-significant-bit. As \nthe msb also represents the sign bit, we can simply route as input to the least-significant and we are done.\nThis is - however - not true, in case the subtraction might result in an overflow. \n\nAlso, we add a nor-gate with inputs from all result bits to detect zero.\n\nimage:../images/how_does_cpu/alu_array_with_zero.svg[width=\u0026#34;60%\u0026#34;]\n\n\n\n==== Overflow Detection\n\nThe last 1-bit ALU cell in the chain has another output \u0026#39;overflow\u0026#39;, to indicate an overflow\nof the addition of two integer values. \nThe encourages the inclined reader to derive the truth table and circuit as an exercise.\n\n//But instead of the propagated solution from Henessey and Patterson,\n//the author wants introduce an alternative implementation \n//to find https://www.geeksforgeeks.org/overflow-in-arithmetic-addition-in-binary-number-system/[here].\n\nimage:../images/how_does_cpu/1bit_alu_cell_with_overflow.svg[width=\u0026#34;120%\u0026#34;]\n\nFor a two\u0026#39;s complement interpretation overflow occurs in two cases:\n\n1. Two positive numbers are added, the result becomes negative\n2. Two negative number are added, the result becomes positive\n\nThe truth table for overflow is as follows (original source can\nbe found http://teaching.idallen.com/dat2343/01f/notes/overflow.txt[here])\n\n[options=\u0026#34;header\u0026#34;]\n|==================\n| Binv| a(n-1) | b(n-1) | c(n-1) | OF \n| 0 | 0 | 0 | 0 | 0\n| 0 | 0 | 0 | 1 | 1\n| 0 | 0 | 1 | 0 | 0\n| 0 | 0 | 1 | 1 | 0\n| 0 | 1 | 0 | 0 | 0 \n| 0 | 1 | 0 | 1 | 0\n| 0 | 1 | 1 | 0 | 1\n| 0 | 1 | 1 | 1 | 0\n| 1 | 0 | 0 | 0 | 0\n| 1 | 0 | 0 | 1 | 0\n| 1 | 0 | 1 | 0 | 0\n| 1 | 0 | 1 | 1 | 1\n| 1 | 1 | 0 | 0 | 1\n| 1 | 1 | 0 | 1 | 0\n| 1 | 1 | 1 | 0 | 0\n| 1 | 1 | 1 | 1 | 0\n|==================\n\nThe circuit generated by Logisim is accordingly:\n\nimage:../images/how_does_cpu/overflow_detection_gates.png[width=\u0026#34;45%\u0026#34;]\n\n\n// To detect this a simple xor with the inputs of carry-in and carry-out is sufficient.\n\n// image:../images/how_does_cpu/1bit_alu_cell_with_xor.svg[width=\u0026#34;120%\u0026#34;]\n\n////\n// ==== Extending the ALU\n// As we can see, the previous ALU is a real minimal example.\n// So we extend it with two additional logic operations NOT and \n// XOR. To keep the gate count low, we make clever usage of the XOR-gate\n// in the half-adders.\n// \n// image:../images/how_does_cpu/fulladder_structure_with_xor.svg[width=\u0026#34;100%\u0026#34;]\n// \n// Also we add eight inverters (4 for each input, A and B) \n// to the table.But to make use of all the whole new functions we need a few \n// more multiplexers.\n// \n// image:../images/how_does_cpu/alu_schematic_extended.svg[width=\u0026#34;100%\u0026#34;]\n// \n// However if we have a look at the following truth table, we see that there\n// is lot unused space. This is reserved for later extensions.\n// \n// [options=\u0026#34;header\u0026#34;]\n// |==================\n// | c3| c2 | c1 | c0 | Y\n// | 0 | 0 | 0 | 0 | A and B\n// | 0 | 0 | 0 | 1 | A or B\n// | 0 | 0 | 1 | 0 | undefined\n// | 0 | 0 | 1 | 1 | undefined\n// | 0 | 1 | 0 | 0 | A\\ \n// | 0 | 1 | 0 | 1 | B\\\n// | 0 | 1 | 1 | 0 | A xor B\n// | 0 | 1 | 1 | 1 | A xor B\n// | 1 | 0 | 0 | 0 | A+B\n// | 1 | 0 | 0 | 1 | A-B\n// | 1 | 0 | 1 | 0 | -\n// | 1 | 0 | 1 | 1 | -\n// | 1 | 1 | 0 | 0 | -\n// | 1 | 1 | 0 | 1 | -\n// | 1 | 1 | 1 | 0 | -\n// | 1 | 1 | 1 | 1 | -\n// |==================\n////\n\n\n\n=== Multiplexer \u0026amp; Demultiplexer\n\nTo select one line out of multiple sources\nwe need another key component, the multiplexer.\nWe can find multiplexer in multiple places,\nhowever in an ALU it used to select one of the logic \nor arithmetic operations, we will see that later.\n\nimage:../images/how_does_cpu/multiplexer_symbol.svg[width=\u0026#34;60%\u0026#34;]\n\nimage:../images/how_does_cpu/multiplexer_principle.svg[width=\u0026#34;75%\u0026#34;]\n\n\nThe demultiplexer- as the name suggest- does the exact opposite task \nand distributes signal on one line (input) to one \nof multiple outputs, depending on the selection bit(s).\n\nimage:../images/how_does_cpu/demultiplexer_principle.svg[width=\u0026#34;75%\u0026#34;]\n\n=== Multiplexer in complementary Pass-Transistor Logic\n\nWe show and implement the multiplexer in pass-transistor-logic,\nas this is the most resource-efficient design...\n\nimage:../images/how_does_cpu/mux_ptl.svg[width=\u0026#34;65%\u0026#34;]\n\n\n\n\n\n\n"},{"id":36,"href":"/docs/digital_logic/04_signs/","title":"04_Signs","section":"Digital Logic","content":"== Extending the binary system\n\nWhile in the previous blog post about addition,\nthe binary numbers had only one interpretation,\nwe extend the system here to include negative (integer)\nnumbers.\n\nimage:../images/how_does_cpu/binary_system.svg[width=\u0026#34;50%\u0026#34;]\n\nThe simplest approach we can think of is to use the most significant bit (MSB)\nas sign bit, where \u0026#39;0\u0026#39; ist intepreted as sign \u0026#39;+\u0026#39; and \u0026#39;1\u0026#39; is interpreted as \u0026#39;-\u0026#39;.\nHowever as we see in the following calculation this does not work as expected:\n\nimage:../images/how_does_cpu/addition_extended.svg[width=\u0026#34;50%\u0026#34;]\n\n=== One complement\n\nAs the previous approach does not fullfill the requirements let us introduce\nthe one complement and two complement here.\nThe one complement is just an inversion of every bit, independent from its significance.\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/one-complement.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ \n\\begin{array}{l}\n00000011_{2} = +3_{10} \\\\\n11111100_{2} = -3_{10}\n\\end{array}\n\\]\n\n=== Two complement\n\nHowever,as can be seen in the panel below, there is still a mismatch\non addition. So, as a second step the inverted number is incremented by one.\nThis leads us to the so-called two\u0026#39;s complement as seen below.\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/two-complement.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ \n\\begin{array}{l}\n00000011_{2} = +3_{10} \\\\\n11111101_{2} = -3_{10}\n\\end{array}\n\\]\n\nAs can be seen in the following calculations, with the two\u0026#39;s complement\nwe get the correct results.\nimage:../images/how_does_cpu/one_and_two_complement.svg[width=\u0026#34;100%\u0026#34;]\n\n=== Overflow \nAs can be seen, in both cases, for one- and two-complement\nan arithmetic overflow is produced. \nIt is very dependent on the cpu achitecture how those are handled,\nbut in every case you get the information as a flag (v) .\n\n=== Implementation of subtraction in a fulladder\n\nTo extend the full-adder with the logic for subtraction we do not \nneed to design from scratch all again. The properties of the xor-gate\nallows the first step of the two\u0026#39;s complement, the inversion of every bit,\nwhile for the second step the increment, we simply use \u0026#39;1\u0026#39; of the subtraction\nswitch as carry-input for the first full-adder stage.\n\nimage:../images/how_does_cpu/fulladder_subtractor.svg[width=\u0026#34;100%\u0026#34;]\n\n\n\n=== Overview table for the number range -7..+7\n \n|==============================================================\n| decimal |binary | one complement | two complement\n| +7 |    0111|     0111  | 0111                  \n| +6 |    0110|     0110  | 0110\n| +5 |    0101|     0101  | 0101\n| +4 |    0100|     0100  | 0100\n| +3 |    0011|     0011  | 0011\n| +2 |    0010|     0010  | 0010\n| +1 |    0001|     0001  | 0001\n| +0 |    0000|     0000  | 0000      \n| -0 |    1000|     1111  | -\n| -1 |    1001|     1110  | 1111\n| -2 |    1010|     1101  | 1110\n| -3 |    1011|     1100  | 1101\n| -4 |    1100|     1011  | 1100       \n| -5 |    1101|     1010  | 1011\n| -6 |    1110|     1001  | 1010\n| -7 |    1111|     1000  | 1001\n|==============================================================\n\n// image:../images/how_does_cpu/digitcircle.svg[width=\u0026#34;100%\u0026#34;]\n\n\n\n"},{"id":37,"href":"/docs/digital_logic/03_binary_system/","title":"03_binary_system","section":"Digital Logic","content":"==  The Binary System\n\n\nAll computer we act with on a daily base do not know about the decimal system we are using, based on the ten digits at our hands.\nAll they know about are the states `on` and `off`. We build an imaginary circuit with a power source a control light - here an LED (Light Emitting Diode)  - and a switch,\nclosing the connection let the light flash. An off light counts as zero, and on light counts as one. Simple as it.We switch the light on\nand get a one.\n\nimage:../images/how_does_cpu/lights.png[title=\u0026#34;A schematic of the imaginary circuit.\u0026#34;]\n\n\nNow we extend this installation with a second light and switch left to current one. We switch the left light on and the right on. What we get as a result is a \u0026#39;2\u0026#39;.\nSwitching the right light on again gets us to 3. Like in our decimal system, the significance of the left light is higher (at least in our example), only the factor differs,\ninstead of 10 the factor is 2. We denote the significance with 2^n where n is the position of the light. Every switch is a bit - more exactly the switch is the input and the\nLED is the output. So with four switches -half a byte - we can count from 0 to 15, while with eight switches - a byte - we can count from 0 to 255. This scheme can be extended as needed.\n\n|==============================================================\n| Binary  | Hex |unsigned Interpretation \n|     0000| 00  |  0                       \n|     0001| 01  |  1                      \n|     0010| 02  |  2                      \n|     0011| 03  |  3                      \n|     0100| 04  |  4                      \n|     0101| 05  |  5                       \n|     0110| 06  |  6                       \n|     0111| 07  |  7                       \n|     1000| 08  |  8                      \n|     1001| 09  |  9                     \n|     1010| 0A  |  10               \n|     1011| 0B  |  11         \n|     1100| 0C  |  12             \n|     1101| 0D  |  13          \n|     1110| 0E  |  14       \n|     1111| 0F  |  15      \n|==============================================================\n\n\nimage:../images/how_does_cpu/example.jpg[title=\u0026#34;showing the binary value 9 (unsigned w/ MSB left).\u0026#34;]\n\n\n== A simple Ripple-Carry adder\n\nLet us do some simple calculations with the goal to derive the necessary logic for an adder-unit.\nThe addition is done like learned in elementary school, just that this time we add binary numbers.\nThe first example works while the second one producesa carry flag besides the (wrong) result.\n\nimage:../images/how_does_cpu/addition.svg[width=\u0026#34;100%\u0026#34;]\n\n= Scheme for combinatorial circuit\nWe develop the RC-adder circuit according to the following scheme, \napplied to evaluate combinatorial circuits\n\n. Define inputs and outputs \n. Construct truth table \n. Evaluate boolean equations / simplify \n. Draw optimized combinatorial circuit \n\n[cols=\u0026#34;a,a\u0026#34;,options=\u0026#34;header\u0026#34;]\n|====\nTruth table for fulladder cell | fulladder cell |\n||\n[width=\u0026#34;100%\u0026#34;,cols=\u0026#34;3,3,3,0,3,3\u0026#34;,options=\u0026#34;header\u0026#34;]\n!===\n! c_in ! A ! B !! c_out ! sum\n! 0 ! 0 ! 0 !! 0 ! 0\n! 0 ! 0 ! 1 !! 0 ! 1\n! 0 ! 1 ! 0 !! 0 ! 1\n! 0 ! 1 ! 1 !! 1 ! 0\n! 1 ! 0 ! 0 !! 0 ! 1\n! 1 ! 0 ! 1 !! 1 ! 0\n! 1 ! 1 ! 0 !! 1 ! 0\n! 1 ! 1 ! 1 !! 1 ! 1\n!===\n|image:../images/how_does_cpu/fulladder_cell.svg[width=\u0026#34;100%\u0026#34;] \n|====\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/sum-equations.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;100%\u0026#34;]\n\\[\n\\begin{aligned}\ns \u0026amp; = (\\overline{c_{in}} \\land \\overline{A} \\land B) \\lor (\\overline{c_{in}} \\land A \\land {\\overline{B}}) \\lor (c_{in} \\land \\overline{A} \\land \\overline{B}) \\lor (c_{in} \\land A \\land B) \\\\\n\u0026amp; = \\overline{c_{in}}(\\overline{A} \\land \\overline{B}) \\lor (A \\land \\overline{B}) \\lor c_{in}((\\overline{A} \\land \\overline{B}) \\lor (A \\land B)) \\\\\n\u0026amp; = \\overline{c_{in}}(A \\oplus B) \\lor c_{in}(\\overline{A \\oplus B}) \\\\\n\u0026amp; = A \\oplus B \\oplus c_{in}\n\\end{aligned}\n\\]\n\n\n\n\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/carry-equations.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;100%\u0026#34;]\n\\[\n\\begin{aligned}\nc_{out} \u0026amp; = \\overline{c_{in}}(A \\land B) \\lor c_{in}(\\overline{A} \\land B) \\lor c_{in}(A \\land \\overline{B}) \\lor c_{in}(A \\land B) \\\\\n\u0026amp; = \\overline{c_{in}}(\\overline{A} \\land \\overline{B}) \\lor (A \\land \\overline{B}) \\lor c_{in}((\\overline{A} \\land \\overline{B}) \\lor (A \\land B)) \\\\\n\u0026amp; = \\overline{c_{in}}(A \\land B) \\lor c_{in}[(\\overline{A} \\land B) \\lor (A\\land \\overline{B}) \\lor A \\land B] \\\\\n\u0026amp; = \\overline{c_{in}}AB \\lor c_{in}(A \\oplus B) \\lor c_{in}AB \\\\\n\u0026amp; = (\\overline{c_{in}} \\lor  c_{in})AB \\lor c_{in}(A\\oplus B) \\\\\n\u0026amp; = AB \\lor c_{in}A \\oplus B\n\\end{aligned}\n\\]\n\nimage:../images/how_does_cpu/fulladder_structure.svg[width=\u0026#34;75%\u0026#34;]\n\n== A simpler approach\n\nInstead of the circuit of a fulladder cell, by only considering the both input signals\nwithout the carry, we evaluate the half-adder cell.\n\n[width=\u0026#34;100%\u0026#34;,cols=\u0026#34;3,3,0,3,3\u0026#34;,options=\u0026#34;header\u0026#34;]\n|===\n| A | B || c_out | sum\n| 0 | 0 || 0 | 0\n| 0 | 1 || 0 | 1\n| 1 | 0 || 0 | 1\n| 1 | 1 || 1 | 0\n|===\n\nAs we can see, the halfadder consists only of the two gates \u0026#39;AND\u0026#39; and \u0026#39;XOR\u0026#39;.\nTwo halfadder and a separate \u0026#39;OR\u0026#39;-gate for the carry-signal result in a fulladder.\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/half-adder.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;30%\u0026#34;]\n\\[\n\\begin{array}{c}\nc = x \\land y \\\\\ns = x \\oplus y\n\\end{array}\n\\]\n\nimage:../images/how_does_cpu/halfadder_structure.svg[width=\u0026#34;75%\u0026#34;]\nimage:../images/how_does_cpu/halfadder2fulladder.svg[width=\u0026#34;75%\u0026#34;]\n\n== Carry-Lookahead Adder\n\nTo avoid the long delay for the carry signal in the rc-adder, \nthe carry-Lookahead has been developed.\nThe signals, (g)enerate and (p)ropagate are defined as follows\n(i being the index of the significance):\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/generate_propagate.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;30%\u0026#34;]\n\\[\n\\begin{array}{c}\ng_{i} = a_{i} \\land b_{i} \\\\\np_{i} = a_{i} \\lor b_{i} \n\\end{array}\n\\]\n\nFrom these helper signals the next carry-value is calculated:\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/carry_lookahead.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;40%\u0026#34;]\n\\[\nc_{i+1} = g_{i} \\lor c_{i} \\land p_{i} \n\\]\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/carry_lookaheads.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;95%\u0026#34;]\n\\[\n\\begin{aligned}\nc_{1} \u0026amp; = g_{0} \\lor c_{0}p_{0} \\\\\nc_{2} \u0026amp; = g_{1} \\lor (g_{0} \\lor c_{0}p_{0})p_{1} = g_{1} \\lor g_{0}p_{1} \\lor c_{0}p_{0})p_{1} \\\\\nc_{3} \u0026amp; = g_{2} \\lor c_{2}p_{2} = g_{2} \\lor (g_{1} \\lor g_{0}p_{1} \\lor c_{0}p_{0}p_{1})p_{2} \\\\\n \u0026amp; = g_{2} \\lor g_{1}p_{2} \\lor g_{0}p_{1}p_{2} \\lor c_{0}p_{0}p_{1}p_{2} \\\\\nc_{4} \u0026amp; = g_{3} \\lor c_{3}p_{3} = g_{3} \\lor (g_{2} \\lor g_{1}p_{2} \\lor g_{0}p_{1}p_{2} \\lor c_{0}p_{0}p_{1}p_{2})p_{3} \\\\\n \u0026amp; = g_{3} \\lor g_{2}p_{3} \\lor g_{1}p_{2}p_{3} \\lor g_{0}p_{1}p_{2}p_{3} \\lor c_{0}p_{0}p_{1}p_{2}p_{3} \\\\\n\\end{aligned}\n\\]\n\n\n*Carry-Lookahead Adder circuit* \n\nimage:../images/how_does_cpu/carry_lookahead_circuit.svg[width=\u0026#34;120%\u0026#34;]\n\n\nAs can be seen the circuit complexity increases with the significance.\nThe table below shows the total view of these different adder implementations.\nOf course the topic of adders is much broader as displayed here, we only introduced \nthe concepts.\n\n*Ripple-Carry Adder*\n\nimage:../images/how_does_cpu/fulladder_array.svg[width=\u0026#34;120%\u0026#34;]\n\n*Carry-Lookahead Adder* \n\nimage:../images/how_does_cpu/cla_fulladder_array.svg[width=\u0026#34;120%\u0026#34;]\n\n\nIn the next blog post we will see, how to extend the range of numbers to the negative space.\n"},{"id":38,"href":"/docs/digital_logic/02_xor/","title":"02_XOR","section":"Digital Logic","content":"== XOR\n\nAs there are a lot of important applications for the exclusive-or (XOR) operation\nit is dedicated an own blog post. Two of the most important are:\n\n- XOR operations are often used in a Linear Feedback Shift Registers (LFSR). \nLFSR are a crucial step  in scrambler / descrambler respectively, \nwhich are used in transmitters / receivers\n- Part of an encryption algorithmus\n- Last but not least an important part of a halfadder.\n\n////\n//as you can expect for a such basic and fundamental operation, but still\n//the situation is a bit different with this operation compared to \u0026#39;and\u0026#39; and \u0026#39;or\u0026#39;.\n////\n\nThe exclusive-or operation xor which is also termed as antivalence\nis denoted as A ⊕ B = Q. Its truth table is shown below\n\n[width=\u0026#34;50%\u0026#34;]\n|================\n| A   | B   |  Q  \n| 0   | 0   |  0  \n| 0   | 1   |  1 \n| 1   | 0   |  1  \n| 1   | 1   |  0  \n|================\n  \nimage:../images/how_does_cpu/xor_symbol.svg[width=250]\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a\u0026#34;]\n|======\n| CMOS XOR \n|image:../images/how_does_cpu/xor_cmos.svg[width=800] \n| # transistor: 12 \n|======\n\n \n\n== Some Applications\n\n=== Linear Feedback Shift Register (LSFR)\nAs described above XOR gates are used in Linear Feedback Shift Registers (LFSR).\nLFSR are often used for test pattern generation.\nThe author selected a simple example of a 3-bit LFSR found in a \nhttps://www.ti.com/lit/an/scta036a/scta036a.pdf[white paper from Texas Instruments].\n\n\nimage:../images/how_does_cpu/lfsr.svg[width=800]\n\nFor this example we need to take a big leap and enter the area of sequential circuits.\nThese are circuits which make use of feedback. The chosen example generates pseudo-random \ntest patterns according to the table below. The registers are feed with the seed value 111,\nafter 8 clock cycles the patterns repeat again.\nOf course real test pattern generators have a much higher bit width.\n\n[width=\u0026#34;50%\u0026#34;]\n|================\n| CLK  | FF1   |  FF2 | FF3  \n| 0    | 1   |  1 | 1  \n| 1    | 0   |  1 | 1\n| 2    | 0   |  0 | 1  \n| 3    | 1   |  0 | 0 \n| 4    | 1   |  0 | 0\n| 5    | 0   | 1  | 0\n| 6    | 1   | 0  | 0\n| 7    | 1   | 1  | 0\n| 8    | 1   | 1  | 1\n|================\n\n=== Halfadder\nIn the next blogpost we dive deeper into the halfadder application.\nThe halfadder essentialy consists of the two following particular equations\nfor sum (making use of the XOR ) and carry (using a simple AND). \n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/half-adder.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;40%\u0026#34;]\n\\[\n\\begin{array}{c}\nc = x \\land y \\\\\ns = x \\oplus y\n\\end{array}\n\\]\n\n"},{"id":39,"href":"/docs/digital_logic/01_boolean_algebra/","title":"01_boolean_algebra","section":"Digital Logic","content":"== Boolean Algebra and Basic Logic Gates\n\nWe are starting (the journey) with three very \nbasic logic functions (or operations), which despite their simplicity \nalready are valid instructions of a regular CPU:\n\n*NOT, AND and OR*\n\n\nLogical functions - also called operations, the author will use both terms interchangebly here -\ncan be described in various ways, most often it is described implicit\nas boolean equation, but it can also be explained explicit in a truth table.\n\nA truth table is a table with the a column for every input and a column for every output.\nSo it shows the output respective the outputs of the function for all possible combinations of inputs. \nAlso they can contain columns with intermediate values.\n\nThe truth tables shown in this lesson are in general very small and show only combinations of two inputs,\nalthough all the functions joining inputs can be expanded to a arbitrary number of inputs.\n\nBoolean equations can be transformed to truth tables and vice versa. Later, we will also introduce \nhttps://en.wikipedia.org/wiki/Karnaugh_map[Karnaugh maps], a way to optimize boolean logic in a graphical way.\n\n=== NOT \nThe not operation also termed as inversion,\nis denoted as \\[\\overline{A} = \\neg A = Q\\]\n\n\n\n[width=\u0026#34;50%\u0026#34; cols=\u0026#34;1,1\u0026#34;]\n|==========\n| A   | Q    \n| 0   | 1    \n| 1   | 0    \n|==========\n\nimage:../images/how_does_cpu/inverter_symbol.svg[width=200]\n\nThe not operation is the only one with only one input, it can not be expanded.\n\nAccordingly the gate-level implementation is also known by the name inverter.\nDespite its seemingly simple functionality there is a lot to say about the inverter \nfor both the logical as well the implementation, so the author will dedicate it an own \npost in the mid-feature.\n\n=== AND\n\nThe and  operation  also termed as conjunction \nis denoted as \\[A \\land B = Q\\]\n\n[width=\u0026#34;50%\u0026#34; cols=\u0026#34;1,1,1\u0026#34;]\n|================\n| A   | B   |  Q  \n| 0   | 0   |  0  \n| 0   | 1   |  0  \n| 1   | 0   |  0  \n| 1   | 1   |  1  \n|================\n\n\nimage:../images/how_does_cpu/and_symbol.svg[width=200]\n\n=== OR \n\nThe or operation also termed as disjunction \nis denoted as \\[A \\lor B = Q\\]\n\n[width=\u0026#34;50%\u0026#34; cols=\u0026#34;1,1,1\u0026#34;]\n|================\n| A   | B   |  Q  \n| 0   | 0   |  0  \n| 0   | 1   |  1 \n| 1   | 0   |  1  \n| 1   | 1   |  1  \n|================\n  \nimage:../images/how_does_cpu/or_symbol.svg[width=200]\n\n////\n=== XOR \n\nThe exclusive-or operation xor which is also termed as antivalence\nis denoted as A ⊕ B = Q\n\n[width=\u0026#34;50%\u0026#34;]\n|================\n| A   | B   |  Q  \n| 0   | 0   |  0  \n| 0   | 1   |  1 \n| 1   | 0   |  1  \n| 1   | 1   |  0  \n|================\n  \nimage:../images/how_does_cpu/xor_symbol.svg[width=200]\n\nThere are a lot of important applications for the exclusive-or operation\nas you can expect for a such basic and fundamaental operation, but still\nthe situation is a bit different with this operation compared to \u0026#39;and\u0026#39; and \u0026#39;or\u0026#39;.\n\n////\n\n\u0026#39;\u0026#39;\u0026#39;\n\nAlthough boolean algebra on itself is an interesting field, we will only skim the subject briefly here, just enough\nto get a feeling and understanding how to work with boolean formulas.\n\n[NOTE]\nIf you are interested in a more profound view, providing induction and proof, \nI refer you to accordingly literature (sources listed at the end).\n\n\nThe laws of the boolean algebra are shown in the following table:\n[%autowidth cols=\u0026#34;40,75a,75a\u0026#34;,options=\u0026#34;header\u0026#34;]\n|====================================================================================================================\n|   Law   |  ∧  (conjunction, AND operator)               |  ∨ (disjunction, OR operator)\n| commutative law   | \\[p \\land q = q \\land p\\]   |\\[p \\lor q = q \\lor p\\]\n| associative law   | \n\\[p \\land (q \\land r) = (p \\land q) \\land r = pqr\\]  |\\[p \\lor (q \\lor r) = (p \\lor q) \\lor r = p \\lor q \\lor r\\]\n| absorptions law   | \\[p \\land (p \\lor q) = p\\]| \\[p \\lor (p \\land q) = p\\]\n| distributive law  | \\[p \\lor (q \\lor r) = (p \\land q) \\lor (p \\land r) = pq \\lor pr\\] |\n\\[p \\lor (q \\lor r) = (p \\lor q) \\lor (p \\lor r) = (p \\lor q)(p \\lor r)\\]\n| neutral elements  | \\[p \\land 1 = p\\] | \\[p \\lor 0 = p\\]                                                   \n| complem. element  |  \\[p \\land \\neg p = 0\\] | \\[p \\lor \\neg p = 1\\] | \n*Reference* | \n*Hans-Jochen Bartsch* | \n*Taschenbuch Mathematischer Formeln, 20. Auflage, p. 27- 28*  |\n|====================================================================================================================\n\n\nYou probably know intuitively - or from school-  the first two laws mentioned in the table, \nthe commutative law and the associative laws.\nAs you can see, every law can be applied to conjunctions as well as disjunctions without any exceptions.\n\nThe commutative law implies that the order of the variables is neutral for the operation and can be swapped without\nchanging the result of the operation. \n\nThe associative law implies, that parenthesis are swappable. Conjunctions can be condensed without operator.\n\nThe absorptions law is probably not known to you from school, as it is only used in logic and has no counterpart in at least\nschool mathmatics.\n\nThe distributive law, again, is known from school. It implies that variables / operations outside of paranthesis needs \nto be applied to all variables in the parenthesis.\n\nThe law of neutral elements, again is something special to boolean algebra. The logic one is the correspondent to \u0026#39;true\u0026#39;,\nand so p and true equals \u0026#39;true\u0026#39;, so as the logic zero is \u0026#39;false\u0026#39; and so p or false equals p.\n\nThe complementary law implies, that to every element (variable) p there is a complementary element (variable) [overline]#p#,\nso that the conjunction results in a  logical zero while disjunction results in a logical one.\n\n\u0026#39;\u0026#39;\u0026#39;\n\nAt this point the author has to leap ahead a bit as some practical issues on the electrical level need some thought on their\nlogic level:\nOn the implementation level (for an electrical implementation) it is rather uncommon to use AND,OR and NOT directly, instead \nthe inverse functions NAND and NOR are used.\n\n\n=== NAND and NOR\n\nThe NAND operation is denoted as \\[\\overline{A \\land B} = Q\\]\nwhile the NOR operation is denoted as \\[\\overline{A \\lor B} = Q\\]\n\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|======\n| NAND | NOR\n|image:../images/how_does_cpu/nand_symbol.svg[width=200] |image:../images/how_does_cpu/nor_symbol.svg[width=200]\n|======\n\nAs you can see, for those two functions the results are exactly the inverse of their respective complement \n(NAND \u0026lt;==\u0026gt; AND,NOR \u0026lt;==\u0026gt; OR), in that sense the author recommends the construction of the respective truth tables \nas an exercise to the reader.\n\n\n\n== The De Morgan theorem\n\nIn addition to those merely basic axioms introduced above, there is the **De Morgan theorem**,\nwhich we need to easily convert between NAND and NOR. For the sake of simplicity we only show for \ntwo elements however the theorem is independent from any number of elements / inputs.\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../images/demorgan_nand.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;75%\u0026#34;] \n\\[\\overline{p_1 \\land p_2} = \\overline{p_1} \\lor \\overline{p_2}\\]\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a,25a,25a,25a,25a\u0026#34;]\n|==========================================================================================\n| A   | B   |\\[\\overline{A}\\] | \\[\\overline{B}\\] | \\[\\overline{AB}\\]  |\\[\\overline{A} \\lor \\overline{B}\\]\n| 0   | 0   |    1         |     1         |          1       | 1\n| 0   | 1   |    1         |     0         |          1       | 1\n| 1   | 0   |    0         |     1         |          1       | 1\n| 1   | 1   |    0         |     0         |          0       | 0\n|==========================================================================================\n\n\n\n\nimage:../images/how_does_cpu/de_morgan_nand_equivalence.svg[width=400]\n\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../images/demorgan_nor.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;75%\u0026#34;] \n\\[\\overline{p_1 \\lor p_2} = \\overline{p_1} \\land \\overline{p_2}\\]\n\n\n[width=\u0026#34;75%\u0026#34; cols=\u0026#34;a,a,25a,25a,25a,25a\u0026#34;]\n|==========================================================================================\n| A   | B   |\\[\\overline{A}\\] | \\[\\overline{B}\\] |  \\[\\overline{AB}\\]| \\[\\overline{A} \\lor \\overline{B}\\]\n| 0   | 0   |    1         |     1         |          1       | 1\n| 0   | 1   |    1         |     0         |          0       | 0\n| 1   | 0   |    0         |     1         |          0       | 0\n| 1   | 1   |    0         |     0         |          0       | 0\n|==========================================================================================\n\n\nimage:../images/how_does_cpu/de_morgan_nor_equivalence.svg[width=400]\n\n\n\nNow we are finally equipped to continue with the electrical part / description.\n\n== Implementation on electrical level\n\nFirst we are introducing some common electronic components and their symbols used in \nelectric circuit schematics.\n\nimage:../images/how_does_cpu/common_symbols.svg[width=500]\n\n=== The diode\n\nWe are beginning the journey with a simplificated circuit design for \u0026#39;and\u0026#39; and \u0026#39;or\u0026#39; called wired logic.\nThis circuit design is so simple it is even not possible to implement an inverter in it.\n\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;100a,100a\u0026#34;]\n|======\n| wired and | wired or\n|image:../images/how_does_cpu/wire_and.svg[width=250] | image:../images/how_does_cpu/wire_or.svg[width=250] \n| # diodes: 2 | # diodes : 2\n|======\n\nAs you can see, this circuit is not to complicate - even laymans in electronc should be able to identify the essential parts\nof - the inputs are connected to a diode, each. A diode is a simple semiconductor which acts as a one-way for electric current.\nSemiconductors are a group of materials (only silicon and germanium are useful here, due to their chemical properties),\nnot really conductor but also no insulator. In fact the conductiviy of the material is dependent on the deliberated pollution \nof their crystall lattice structure with elements of the fifth main group, for an n(egative)-dotted material respectively of the third main group\nfor a p(ositive) dotted material. This process is called dotting. For the interested reader https://www.electrical4u.com/semiconductor-physics/[here]\nis a link to all the physical background the author was to lazy to repeat since it is often and better explained on the internet already ;-) .\n\nimage:../images/how_does_cpu/diode_structure.svg[width=450] \n\nAll we need to know right know is that a diode consist of one substrate (in most cases today silicon) which becomes n-dotted on one side and p-dotted on the other, \nforming a pn-junction in between acting as said one-way barrier: It is possible for electrons to rush from n-side to the p-side but not the other way round. \n\nThe second component of the circuits shown above is a resistor, its solely purpose is to reduce the current flowing. \nFor wire-and it is wired as pull-up resistor while for wire-or it is wired as pull down resistor.\nThe wire-and only reaches a sufficient high-level if all inputs go high-level. Similar the wire-or only goes low-level if neither of the inputs\ngoes high level.To prevent current flowing from pull-up resistor to the output of the previous circuit (wire and) respectively current flowing \nfrom one input back to the other input (wire-or), the diodes are in place.\n\nA problem of this setup which we will definitely encounter at some point, is that the signal is weakend when flowing from input to the output \nand there is no ability  provided to recover the signal, so at the output the signal level might not be distinguished correctly by the subsequent circuit. \nAllow the author a remark in a subtle detail in the terminology at this point: Although it is often described as amplifying we want holding on here, that we want a \nsomewhat \u0026#39;intelligent\u0026#39; signal amplifier here recognizing the signal level of the input signal and recovering, complementary to a \u0026#39;stupid\u0026#39; amplifier just\namp-ing the input signal.\n\nSo the diodes are a fine component, e.g. useful when protecting parts of the circuit from electrostatic discharge \n(https://www.allaboutcircuits.com/textbook/semiconductors/chpt-9/electrostatic-discharge/[ESD]), but for our logic it is not sufficient.\n\nWhat if we had a component capable to amplify the signal, so we could design circuits also recovering the signal levels with it?\nLuckily such a component exists and is introduced in the next section.\n\n////\n//=== The classical transistor\n//\n//Before we actually introduce the transistor let us do a peek into history. Some of the first computers built were using \n//http://www.historicsimulations.com/ZuseZ3.html[electromechanical relays], \n//whereas others relied on https://www.thoughtco.com/history-of-the-eniac-computer-1991601[vacuum tubes]. \n//The very first one(s) were purely https://www.fourmilab.ch/babbage/[mechanical].\n//Here we want to focus on the vacuum tubes - in particular the triode -as black boxes as on the outside the working principal is roughly comparable to that \n//of a standard / classic bipolar transitor.\n//\n//[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n//|======\n//|Bipolar Junction Transistor (BJT) | Triode (certain type of vacuum tube)\n//||image:../images/how_does_cpu/bjt_structure.svg[width=450] | image:../images/how_does_cpu/triode.svg[width=300]\n//| *\u0026gt;* A current on basis controls the current between collector and emitter     \n//| *\u0026gt;* A voltage on grid controls the current between collector and emitter \n//|======\n////\n\n\n////\nA transistor allows the implementation of the operations introduced above and at one go also allows allows the amplifying of the signal.\nIt is a switching element which can be controlled with a control voltage, similar to an electromechanical relay,\nwhere a small current in a coil builds up a magnetic field which moves the armature to close (or open, depending on the construction) \nthe contacts of the load circuit.\n////\n\n=== The MOSFET transistor\n\nThe type of transistor we want to introduce and use here is a MOSFET (Metal Oxid Semiconductor Field Effect Transistor) - as opposed to classical bipolar transistor.\nAs the name suggests a MOSFET is a transistor (or semiconductor) where the load currrent can be controlled by the strength of the electrical field, created on the gate input\n//https://www.power-and-beyond.com/whats-the-difference-between-mosfet-and-bjt-a-909006/\n\n\nimage:../images/how_does_cpu/mosfet_model.svg[width=500]\n\nThe image above sketches the principal structure of a mosfet on the silicon. Source and drain are both connected to an own n-well, in the p dotted substrate,\nwhile the gate in between is isolated by a thin silicon dioxide layer. There is a forth connector \u0026#39;bulk\u0026#39;, leading to the substrate, in discrete MOSFETs connected to the source,\nbut for now this one is not relevant.\nThere is a lot of complex physics behind the workings of a MOSFET all we want to know for now, is that when a voltage is applied to the gate, an electrical field is induced, \nwhich creates a chanel between source and drain and allows electrons to flow from source to drain. The higher the gate voltage the bigger  (wider) the channel, the more electrons \nflowing (until a certain boundary of course). And if the gate voltage is zero, also the channel is non-existent.\n\nimage:../images/how_does_cpu/inverter_nmos.svg[width=500]\n\nCommon used symbols for MOSFET used in electrical schematics as well as some other we need due to course are shown below, some has more then only one, especially the MOSFET has a number \nof sligthly various symbols reflecting the differences in the physical component.\n\nimage:../images/how_does_cpu/mosfet_symbols.svg[width=500]\n\nWith the MOSFET element introduced and a single resistor,an element which reduces the current flow, added, we can straight-forward implement an inverter circuit as shown in the image above.\nSource is connected to the ground and Drain is connected to the inverter output and also to the voltage source via a high-impedance resitor. Gate is the input of the inverter.\nWhen the voltage is set to low on the gate, the MOSFET does not conduct and so the potential available on the output is sufficient for a logic one.\nWhene a voltage is set to the gate,the drain-source path of the MOSFET becomes conductive, the potential available on the output breaks down an drains away via the drain-source path.\n\nimage:../images/how_does_cpu/inverter_cmos.svg[width=500]\n\n\u0026#39;\u0026#39;\u0026#39;\nOn the electrical level inverter has two different tasks to fullfill\n\n1. Refreshing the signal (level) the inverters gets from the preceeding circuit \n2. Actually, inverting the signal \n\nThere are also integrated circuits, called buffer or driver, solely dedicated to the first task mentioned, we will discuss that in a later blog post / lesson.\nHere we want to focus only on the logical part of inverting the signal, although for that both functions are equal important, thats why they are combined in one \ncircuit. Of course, the logic signals have to be refreshed also in other logical circuits - like and and or - but in most cases this task is solely handeled by \nthose inverter stages, afterwards or before.\n\nimage:../images/how_does_cpu/inverter_symbol.svg[width=200]\n\nIn the symbol the first task, the refreshing of the signal (level), is indicated by the triangle, while the little circle denotes the actual inverting function.\n\n\u0026#39;\u0026#39;\u0026#39;\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|======\n| NMOS NAND | NMOS NOR\n|image:../images/how_does_cpu/nand_nmos.svg[width=200] | image:../images/how_does_cpu/nor_nmos.svg[width=500] \n| # transistor: 2 | # transistor: 2 \n|======\n\nNow it becomes clear, why the inverse function of AND and OR on the gate level is simpler than the original function. \nBecause you have to add an inverter circuit afterwards, increasing the transistor count.\n\nOne big drawback of the implementation is the high power consumption caused by the pull-up resistor. Let us see if there is a way to\nsolve that issue. What if there is transistor labeled PMOS with a complementary structure - p-wells on an n dotted substrate - to our \nup-to-now used NMOS circuit?\n\nWhen we use those instead the resistor for the pull-up path we can drastically reduce power dissipation. \nAs you guess this technique, both types of transistor combined, exists and is named CMOS ( Complementary Metal Oxid Semiconductor).\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|======\n| CMOS NAND | CMOS NOR \n|image:../images/how_does_cpu/nand_cmos.svg[width=250] | image:../images/how_does_cpu/nor_cmos.svg[width=500] \n| # transistor: 4 | # transistor: 4 \n|======\n\n////\n//===From discrete to silicon\n////\n\nIt becomes apparent now where the CMOS technology has its name from:\nAs we can see in the implementation of NAND and NOR in CMOS technology, the P circuit above is exactly the complementary of the N circuit below.\nFor the inverter this property was just not recognizable due to the symmetry.\nBut we can also see the drawback of the CMOS technology: The number of transistors doubles, increasing the effort and complexity of the manuacturing process\n(complexer masks and layouts, more processing steps due to different types of transistors, nmos and pmos both on one wafer) and the integrated circuit as the end product.\n\nHowever the toolchain, the CMOS process and its related technologies are evolved and matured already since decades, so today it does not matter anymore, in fact\nrecently Google even published the https://github.com/google/skywater-pdk[SkyWater Open Source PDK 130], a so-called Process Design Kit offering electrical engineers \na tool(chain) to produce designs for Application Specific Integrated Circuits  which then can directly be manufactured using a 130nm process. \nYou can read more about it https://hackaday.com/2020/06/30/your-own-open-source-asic-skywater-pdf-plans-first-130-nm-wafer-in-2020/[here on Hackaday].\n\nThat was a first slight look into boolean logic and its implementation on silicon, of course there is a lot more to it than only one reference design, \nalso we did not had a look yet for ESD measurements and protection circuits for the inputs and output.\n\nIn the next post we have a look on the exclusive-or (XOR) operation.\n\n\n\n"},{"id":40,"href":"/pages/overview-de/","title":"How does a CPU work? Overview","section":"Pages","content":"= Wie funktioniert eine CPU - Inhaltsverzeichnis\n\n== *Einführung und Überblick*\n\n_Einführung und Überblick_\n\nJedes Thema dieses Kurses ist in zwei Teile gegliedert:\nEinen Teil über die mathematische Seite der digitalen Logik,\nidealerweise fast unabhängig von den Implementierungsdetails\nund einen konkreteren Teil, der genau diese Details behandelt.\nIm konkreten Teil werden wir hauptsächlich die Implementierung\nauf einer elektrischen Ebene diskutieren, obwohl es auch andere Lösungen\nmöglich, die auf https://erik-engheim.medium.com/microprocessors-running-on-air-a47a702dd41f[fluid dynamics],\noder https://www.photonics.com/Articles/All-Optical_Logic_Gates_Show_Promise_for_Optical/a63226[optische Gatter],\ndie meisten Computer und Logikgatter basieren immer noch auf Elektronik und Halbleitertechnologie, und das wird sich auch mit\nhttps://www.azom.com/article.aspx?ArticleID=17173[Quantencomputer], der hauptsächlich mit der Wahrscheinlichkeitstheorie verknüpft ist, nicht ändern.\nWahrscheinlichkeitsrechnung. Doch mit dem Quantencomputing\nwerden sich jedoch die Grundlagen, die der Autor hier beschreibt, komplett ändern.\n\n== *Kombinatorische Logik*\n_https://wehrend.uber.space/docs/digital_logic/00_combinatorial_logic[Einführung in die kombinatorische Logik]_\n\nKurze Einführung in die kombinatorische Logik und ihre verschiedenen Beschreibungsmodelle.\n\n== *Ein erster Blick auf die digitale Logik*\n\n_https://wehrend.uber.space/docs/digital_logic/01_boolean_algebra/[Boolesche Algebra, grundlegende logische Gatter und ihre Implementierung]_\n\nIn dieser Lektion lernen wir Wahrheitstabellen und die boolesche Notation kennen und erfahren etwas über\nDe Morgans Gesetze.\nAußerdem werfen wir einen Blick auf die grundlegendsten Logikgatter und warum sie in der Elektronik normalerweise nicht als solche implementiert werden.\nin der Elektronik nicht als solche implementiert werden, sondern als NAND- und NOR-Gatter.\n\n== *Sie müssen sich entscheiden!*\n\n_https://wehrend.uber.space/docs/digital_logic/02_xor/[Ein komplexes Gatter: XOR]_\n\nEine weitere CPU-Anweisung und als Nebenbemerkung und Vorbereitung auf das nächste Thema,\nwerfen wir einen Blick auf das XOR-Gatter. Wie in der ersten Lektion sehen wir uns zuerst den logischen\nTeil und dann seine Übersetzung in eine elektrische Implementierung.\n\n\n== *01+01 = 10*\n\n_http://wehrend.uber.space/docs/digital_logic/03_binary_system/[Binäre Systeme (Teil I) und Kombinatorische Logik (Teil I)]_\n\nHier erklären wir das Grundkonzept des Zählens mit nur zwei verschiedenen Zuständen.\nAußerdem lernen wir, wie man zwei positive ganze Zahlen im Binärsystem addiert, die für eine\ndie für eine Volladdierung benötigte Logik ableiten, um dann in das Thema der kombinatorischen Logik einzutauchen.\n\n== *Es gibt viel Platz im negativen Raum*\n\n_http://wehrend.uber.space/docs/digital_logic/04_signs/[Binärsystem (Teil II) Vorzeichenbehaftete ganze Zahl]_\n\nZweiter Teil über das Binärsystem. In diesem Beitrag lernen wir über die Ein- und Zwei\nKomplement und Subtraktion.\n\n\n== *Addieren ist nicht alles*\n\n_http://wehrend.uber.space/docs/digital_logic/05_alu/[Kombinatorische Logik (Teil II), eine einfache ALU]_\n\nMit diesem zweiten Kapitel über kombinatorische Logik wollen wir die erste Serie abschließen.\nWir werden den Addierer zu einer einfachen ALU erweitern\n\n\n== *Übersicht, was als nächstes kommt*\n\nVom Kombinatorischen zum Sequentiellen_\n\nIn diesem ersten Kurs haben wir einige Grundlagen über digitale Logik gelernt. Aber all diese Beispiele\nverwenden nur statische Logik, uns fehlt noch ein Konzept, wie man berechnete Werte speichert.\nWir müssen das Konzept der Register und der sequentiellen Logik lernen.\nDies wird das Hauptthema der zweiten Beitragsserie sein.\n= Wie funktioniert eine CPU - Inhaltsverzeichnis\n\n== *Einführung und Überblick*\n\n_Einführung und Überblick_\n\nJedes Thema dieses Kurses ist in zwei Teile gegliedert:\nEinen Teil über die mathematische Seite der digitalen Logik,\nidealerweise fast unabhängig von den Implementierungsdetails\nund einen konkreteren Teil, der genau diese Details behandelt.\nIm konkreten Teil werden wir hauptsäc\n\n== Extra\n\n== *Lass mich das nachschlagen*\n\n_Erster Blick in den Speicher und Look-Up-Tables (LUTs)_\n\nIn dieser Lektion lernen wir, dass - im Prinzip - jede Form von kombinatorischer Logik\nin \u0026#39;Software\u0026#39; umgewandelt werden kann, indem man sie im Speicher ablegt. In einem praktischen Beispiel werden wir\nzeigen wir, wie ein DDS-Sinuswellengenerator eine Look-Up-Table (LUT) verwendet, um den Sinus zu replizieren.\n\n\n"},{"id":41,"href":"/pages/overview/","title":"How does a CPU work? Overview","section":"Pages","content":"= How does a CPU work - Table of contents\n\n==  *Introduction and overview*\n\n_Introduction and overview_\n\nEvery topic of this course is broken up into two parts:\nA part about the mathematical side of digital logic,\nideally almost independent from implementation details\nand a more concrete part handling this very details.\nIn the concrete part we will mostly discuss the implementation\non an electrical layer, though there are still other solutions\npossible based on https://erik-engheim.medium.com/microprocessors-running-on-air-a47a702dd41f[fluid dynamics], \nor https://www.photonics.com/Articles/All-Optical_Logic_Gates_Show_Promise_for_Optical/a63226[optical gates], \nmost computers and logic gates are still based on electronics and semiconductor technology and this will not \nchange with https://www.azom.com/article.aspx?ArticleID=17173[quantum computing], which is mostly tied to / adjunct to\nprobability theory. However with quantum computing\nthe fundamentals behind which the author describes here will completly change.\n\n==  *Combinatorial Logic*\n_https://wehrend.uber.space/docs/digital_logic/00_combinatorial_logic[Introduction to Combinatorial Logic]_\n\nShort introduction to combinatorial logic,and its various description models.\n\n==  *A first look at digital logic*\n\n_https://wehrend.uber.space/docs/digital_logic/01_boolean_algebra/[Boolean Algebra, basic logic gates and their implementation]_\n\nIn this lesson we will discover truth tables, boolean notation and learn about\nDe Morgan\u0026#39;s laws.\nAlso we have a look at the most basic logic gates and why their are usually are not\nimplemented as such in electronics, having a look at NAND and NOR instead.\n\n==  *You have to choose!*\n\n_https://wehrend.uber.space/docs/digital_logic/02_xor/[A complex gate: XOR]_\n\nAnother CPU instrucion and as a side-note and preparation for the next topic, \nwe have a look at the XOR gate. As in the first lesson we\u0026#39;ll see first the logic \npart and then its translation into an electrical implementation.\n\n\n==  *01+01 = 10*\n\n_http://wehrend.uber.space/docs/digital_logic/03_binary_system/[Binary systems (Part I) and Combinatorial Logic (Part I)]_\n\nHere we explain the basic concept of how to count with only two different states at hand.\nAlso we will learn how to sum up two positive integer values in the binary system, derivate\nthe logic needed for a full-adder, to dive into the topic of combinatorial logic.\n\n==  *There is plenty room in the negative space*\n\n_http://wehrend.uber.space/docs/digital_logic/04_signs/[Binary Systems (Part II) signed integer]_\n\nSecond part about the binary system. In this post we learn about one- and two-\ncomplement and subtraction.\n\n\n==  *Adding is not all*\n\n_http://wehrend.uber.space/docs/digital_logic/05_alu/[Combinatorial Logic (Part II), a simple ALU]_\n\nWe want close the first series by this second chapter about combinatorial logic.\nWe will extend the adder to a simple ALU\n\n\n==  *Outline, what comes next*\n\n_From combinatorial to sequential_\n\nIn this first course we learned some basics about digital logic. But all these examples\nuse only static logic, we are still lacking a concept of how to store computed values.\nWe need to learn the concept of registers and sequential logic.\nThis will be the main topic of the second post series.\n\n\n= Extra\n\n==  *Let me look that up*\n\n_First look into Memory and Look-Up-Tables (LUTs)_\n\nIn this lesson we learn, that - in principal - every form of combinatorial logic\ncan be transformed into \u0026#39;software\u0026#39; by putting it into memory. In a practical example we will\nshow how a DDS sine wave generator use a Look-Up-Table (LUT) to replicate the sine.\n\n\n\n"},{"id":42,"href":"/pages/about/","title":"About","section":"Pages","content":"A simple static blog meant for writing about topics like electronics \u0026amp; computation and - maybe - philosophy.\n\n\u0026#39;\u0026#39;\u0026#39;\n\nDear reader of my humble blog , I am Sven Wehrend, a scanner personality born 1987,\ninterested in a wide range of different topics reaching from technology over psychology to spirituality.\n\nI studied Computer Engineering at the HTW Berlin (Bachelor) and TU Berlin (Master).\n\n\u0026#39;\u0026#39;\u0026#39;\nA german version can be found https://wehrend.uber.space/pages/ueber[here]."},{"id":43,"href":"/posts/web/00_setting_up_nikola/","title":"Setting up a static blog with Nikola","section":"Web","content":"I picked up Nikola some months ago as I was searching for a simple static-site-generator to setup a blog with minimal effort.\n\nTo make things a bit more interesting and at the same time easier we will use Nikola in a Docker container.\nSo I require an almost basic understanding for Docker here.\n\nFirst create a directory on our host system, where you want the files stored, e.g. \u0026#39;blog\u0026#39; in your home directory.\n\nYou can pull unoffical images with the most recent version via:\n\n\n docker pull dragas/nikola\n\nand run the image getting a (bash) shell via:\n\n\n docker run -it --network=\u0026#34;host\u0026#34; -v ~/blog:/nikola dragas/nikola\n\n\nhere the option flag -it stands for interactive - which, in fact, it does not but it is easy to memorize so, so let it be so.\nFurthermore we need to add our volume, a storage resource which is shared between the host system and the docker container. So we add\n-v ~/blog for our blog located in our home directory (for linux, on windows systems the paths differ).\nAlso we need to add the option --network=\u0026#34;host\u0026#34; otherwise we won\u0026#39;t be able to access the webpage from our host system, and thus from our browser.\nIf you are interested, check https://docs.docker.com/engine/reference/run/[Docker run]\n\nHere you can execute the common bash commands like cd, ls, ps and so on, feel free to test and explore\nhttps://dev.to/awwsmm/101-bash-commands-and-tips-for-beginners-to-experts-30je[Basic bash commands] :-)\n\nNow that you have explored the system a bit, you can initiate a basic nikola project via:\n\n\n nikola init\n\n\nYou will be led through some questions regarding your blog, for destination simply set .\n\nWe create a first post with:\n\n nikola new_page -t \u0026#34;Hello World\u0026#34;\n\n\nWrite the post on your host system on an editor of your choice it is located in blog/posts/hello-world.rst and then build via:\n\n\n nikola build\n\n\nTo test the website, start the test server with:\n\n nikola serve\n\nand head your browser to http://localhost:8080[http://localhost:8080] .\n\nimage:../nikola_default.png[Unnamed image]\n\n\nThis is cool, but surely we want do a bit of styling and customization now, as the current look is pretty standard.\nThe author\u0026#39;s preference is a plain and simple style without much unnecessary payload.So I searched for such theme, but they were not\nto my liking. Then I found the https://themes.getnikola.com/v8/hyde/[Nikola port of Hyde]\n\nThe theme can be installed with:\n\n nikola theme -i hyde\n\nAfter installation the theme needed some tweaking of the about section in the sidebar. So the version shown here diverges\nfrom the original look. Adjustments were made to the file assets/css/hyde.css in the directory of the freshly installed theme.\nIdeally the changes should be made in an additional file custom.css\n\nimage:../nikola_hyde.png[Unnamed image]\n\nMuch better now!\n\nIf we are satified with the result, we can deploy our new static site to web space of our choice. For this we adjust the deploy setting \nin th conf.py file. This can look like the following.\n\n[source,python]\n....\n\nDEPLOY_COMMANDS = {\n    \u0026#39;default\u0026#39;: [\n        \u0026#39;rsync -rav --delete output/ user@server:/var/www/virtual/user/html\u0026#39;,\n        \u0026#39;rdiff-backup output ~/blog-backup\u0026#39;,\n    ]\n}\n....\n\nNow, we can simply execute this command by typing\n\n nikola deploy\n\nand the new site is part of the www.\n"},{"id":44,"href":"/pages/ueber/","title":"Über","section":"Pages","content":"Ein einfaches, statisches Blog, in dem über Themen wie Elektronik, Computer und - vielleicht - Philosophie geschrieben wird.\n\n\u0026#39;\u0026#39;\u0026#39;\n\nLieber Leser meines bescheidenen Blogs, ich bin Sven Wehrend, eine Scanner-Persönlichkeit, geboren 1987,\nIch interessiere mich für ein breites Spektrum an Themen, von Technik über Psychologie bis hin zu Spiritualität.\n\nIch habe Technische Informatik an der HTW Berlin (Bachelor) und der TU Berlin (Master) studiert.\n\n\u0026#39;\u0026#39;\u0026#39;\n\n==== Aus dem englischen übersetzt mit https://deepl.com[deepl.com]."},{"id":45,"href":"/posts/web/01_writing-about-math-with-asciidoc/","title":"Writing about math with Asciidoc","section":"Web","content":"While drafting a blog post, part of a series of posts intended to be published in the future,\nI discovered a lack of my tooling in Nikola. When adding mathematical formulas, \nI realized that there is no default-way of rendering images from those math formulas,\nand inserting them as image-tags into the html. Instead math formulas are handled via JS, which I try \nto reduce to an absolute minimum on my site.\nSo I started to implement a rather quick-and-dirty plugin to do exactly this transformation, using \nlatex and dvipng or dvisvgm. \nThen I come across https://erikwinter.nl/articles/2020/why-i-built-my-own-shitty-static-site-generator/[this blog post] \nwhere reading about https://asciidoc.org/[asciidoc] written in python and its successor https://asciidoctor.org/[asciidoctor] written\nin ruby supporting different display formats. Ideal for the content I had in mind. So I installed the Nikola plugin asciidoc \n(which is mostly a wrapper to the asciidoc binary called as a subprocess), via\n\n nikola plugin -i asciidoc\n\nin my local environment and converted my blogpost(s) first semi-automatically which is, due to the metadata-section from \nNikola, not the very best idea and continued manually.\nAfter some frustrations with the paths for the latex filter inside asciidoc it was working.\n\nSo as a sample of one of the future blogposts here one or rather two math-equations rendered this way:\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/half-adder.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;,width=\u0026#34;45%\u0026#34;]\n\\[\n\\begin{array}{c}\nc = x \\land y \\\\\ns = x \\oplus y\n\\end{array}\n\\]\n\nJust as side-note: It describes a halfadder.\n\n*Edit* Improved grammar.\n"},{"id":46,"href":"/docs/digital_logic/agenda2/","title":"Agenda2","section":"Digital Logic","content":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN\" \"http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd\"\u003e- no title specified Combinatorial Logic\nSequential Logic\n00_combinatorial_logic\n10_sequential_logic\n01_boolean_algebra\n11_clocks,flipflops_and_registers\n02_XOR\n12_automata\n03_binary_system\n13_cpu_control 04_Signs\n14_programmable Logic\n05_ALU\n15_test_logic\n06_Memory\n16_ HDLs (VHDL+Verilog)\n17_Register-Transfer-Level\nComputer Architecture / Processor design\n20_RISC_V 21_ISA, Assembler + Linker\n22_RISC_V_implementation\nExcursions\nX0_Multiplication\nX1_Division X2_Trigonometric functions (CORDIC)\nX3_Sigmoid functions\nOther topics\nO00_Consciousness "},{"id":47,"href":"/docs/digital_logic/agenda3/","title":"Agenda3","section":"Digital Logic","content":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN\" \"http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd\"\u003e - no title specified Combinatorial Logic\nSequential Logic\n00_combinatorial_logic\n10_sequential_logic\n01_boolean_algebra\n11_clocks,flipflops_and_registers\n02_XOR 12_automata\n03_binary_system 13_cpu_control 04_Signs\n14_programmable Logic\n05_ALU 15_test_logic\n06_Memory 16_ HDLs (VHDL+Verilog)\n17_Register-Transfer-Level\nComputer Architecture / Processor design\n20_RISC_V 21_ISA, Assembler + Linker\n22_RISC_V_implementation\nExcursions\nX0_Multiplication\nX1_Division X2_Trigonometric functions (CORDIC)\nX3_Sigmoid functions\nOther topics\nO00_Consciousness "},{"id":48,"href":"/drafts/alu2/","title":"Alu2","section":"Drafts","content":".. title: How does a CPU work? The swiss knife (Part II)\n.. slug: how-does-a-cpu-work-alu-2\n.. date: 2022-02-09\n.. category:\n.. link: \n.. description: \n.. type: text\n\n=== Instruction table\n\n[options=\u0026#34;header\u0026#34;]\n|==================\n| logic operations | description| implementation | data type / size\n| and              | basic boolean Op| -            | bit\n| or               | basic boolean Op|-             | bit\n| not              | basic boolean Op|-             | bit\n| xor              | complex boolean Op|-             | bit\n| shl              | shift left |- |various\n| shr              | shift right|- |various \n|==================\n\n[options=\u0026#34;header\u0026#34;]\n|==================\n| control instructions | description| data type / size\n| ld  | load  | various\n| st  | store | various\n| jx  | jump (x= gt,eq, lt )   | various\n\n|==================\n\n[options=\u0026#34;header\u0026#34;]\n|==================\n| arithmetic operations|description| implementation | data type / size\n| ashl             | arithmetic shift left |- | various\n| ashr             | arithmetic shift right|- | various\n| inc             | increment |- | various\n| dec             | decrement |- | various\n| add |addition | - | (u) integer\n| sub |subtraction | - | (u) integer\n| mul | multiplication | software-routine or HW | (u)integer\n| div | division | software-routine or HW | (u)integer\n| sin | sine     | software-routine (Cordic) | (u) integer\n| cos | cosine     | software-routine (Cordic) | (u) integer\n| tan | tangens    | software-routine (Cordic) | (u) integer\n|==================\n\n\n== Compare operations\nThe first type of instructions we have nor called not even discussed\nare compare instructions. We first show a comparator for a single bit,\nand then derive an comparator for arithmetic operations.This whole section \nis just a quotation, the original source is found \nhttps://www.electrical4u.com/digital-comparator/[here].\n\n\n\n[options=\u0026#34;header\u0026#34;]\n|==================\n| A | B | \u0026gt; (G) | = (E)| \u0026lt; (L)\n| 0 | 0 | 0 | 1 | 0\n| 0 | 1 | 0 | 0 | 1\n| 1 | 0 | 1 | 0 | 0\n| 1 | 1 | 0 | 1 | 0\n|==================\n\nThis leads us to three simple boolean equations (greater than, equal, less than):\n\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/greater_than.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;22%\u0026#34;]\n\\[ G = A\\overline{B} \\]\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/equal.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;30%\u0026#34;]\n\\[ E = \\overline {A \\oplus B} \\]\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/less_than.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;22%\u0026#34;]\n\\[ L = \\overline{A}B \\]\n\nimage:../images/how_does_cpu/single-bit-comparator.svg[width=\u0026#34;80%\u0026#34;]\n\nWe extend this scheme to a  4 bit width comparator as follows:\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/A_B.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;70%\u0026#34;]\n\\[ A = A_{1}A_{2}A_{3}A_{4} \\quad and \\quad B=B_{1}B_{2}B_{3}B_{4} \\]\n\n\u0026#39;\u0026#39;\u0026#39;\u0026#39;\n=== Greater than\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/G_equations.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;100%\u0026#34;]\n\\huge\n\\[ \n\\begin{array}{l}\n(1) \\quad A_{1} \u0026gt; B_{1} =\u0026gt; A \u0026gt; B \\quad or \\quad G=1 \\\\\n(2) \\quad A_{1} = B_{1};A_{2} \u0026gt; B_{2} =\u0026gt; A \u0026gt; B  \\quad or \\quad G=1 \\\\\n(3) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} \u0026gt; B_{3} =\u0026gt; A \u0026gt; B  \\quad or \\quad G=1 \\\\\n(4) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} = B_{3};A_{4} \u0026gt; B_{4} =\u0026gt; A \u0026gt; B  \\quad or \\quad G=1\n\\end{array}\n\\]\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/G_equations2.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;100%\u0026#34;]\n\\huge\n\\[ \n\\begin{array}{l}\nFor \\quad (1) \\quad G = A_{1}\\overline{B}_{1} \\\\\nFor \\quad (2) \\quad G= \\overline {A_{1} \\oplus B_{1}} (A_{2}\\overline{B_{2}}) \\\\\nFor \\quad (3) \\quad G= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (A_{3}\\overline{B_{3}}) \\\\\nFor \\quad (4) \\quad G= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}}  (A_{4}\\overline{B_{4}})\n\\end{array}\n\\]\n\nFrom this follows, that G=1 when either of the above equations holds...\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/G_equations3.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;100%\u0026#34;]\n\\huge\n\\[ \n\\begin{array}{l}\nG= A_{1}\\overline{B}_{1} + \\overline {A_{1} \\oplus B_{1}} (A_{2}\\overline{B_{2}}) + \n\\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (A_{3}\\overline{B_{3}}) + \\\\\n\\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}}  (A_{4}\\overline{B_{4}})\n\\end{array}\n\\]\n\n\u0026#39;\u0026#39;\u0026#39;\u0026#39;\n=== Less than\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/L_equations.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;100%\u0026#34;]\n\\huge\n\\[ \n\\begin{array}{l}\n(5) \\quad A_{1} \u0026lt; B_{1} =\u0026gt; A \u0026lt; B \\quad or \\quad L=1 \\\\\n(6) \\quad A_{1} = B_{1};A_{2} \u0026lt; B_{2} =\u0026gt; A \u0026lt; B  \\quad or \\quad L=1 \\\\\n(7) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} \u0026lt; B_{3} =\u0026gt; A \u0026lt; B  \\quad or \\quad L=1 \\\\\n(8) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} = B_{3};A_{4} \u0026lt; B_{4} =\u0026gt; A \u0026lt; B  \\quad or \\quad L=1\n\\end{array}\n\\]\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/L_equations2.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;100%\u0026#34;]\n\\huge\n\\[ \n\\begin{array}{l}\nFor \\quad (5) \\quad L= \\overline{A}_{1}B_{1} \\\\\nFor \\quad (6) \\quad L= \\overline {A_{1} \\oplus B_{1}} (\\overline{A_{2}}B_{2}) \\\\\nFor \\quad (7) \\quad L= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (\\overline{A_{3}}B_{3}) \\\\\nFor \\quad (8) \\quad L= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}}  (A_{4}\\overline{B_{4}})\n\\end{array}\n\\]\n\nFrom this follows, that L=1 when either of the above equations holds...\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/L_equations3.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;100%\u0026#34;]\n\\huge\n\\[ \n\\begin{array}{l}\nL= \\overline{A}_{1}B_{1} + \\overline {A_{1} \\oplus B_{1}} (\\overline{A_{2}}B_{2}) + \n\\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (\\overline{A_{3}B_{3}}) + \\\\\n\\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} (\\overline{A_{4}}B_{4})\n\\end{array}\n\\]\n\n\u0026#39;\u0026#39;\u0026#39;\u0026#39;\n=== Equal\n\nLast but not least for equal holds:\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/E_equation.svg\u0026#34;,imgfmt=\u0026#34;svg\u0026#34;, width=\u0026#34;100%\u0026#34;]\n\\huge\n\\[ \n\\begin{array}{l}\nA_{1}=B_{1}; A_{2}=B_{2};A_{3}=B_{3};A_{4}=B_{4} =\u0026gt;  E=1 \\\\\nE = \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} \\quad \\overline {A_{4} \\oplus B_{4}} \n\\end{array}\n\\]\n\nThus, the logical circuit is designed as follows:\n\nimage:../images/how_does_cpu/four-bit-comparator.svg[width=\u0026#34;120%\u0026#34;]\n\n==== Comparator circuit\n\nThe 4063 cmos IC is a 4 bit comparator IC.\nIt can be cascaded to cover wider bit ranges.\n\n\n== Shift operations\n\nThe next important set of operations are the shift \noperations. Those can be divided in logical as\nwell as arithmetic shift operations.\n\nimage:../images/how_does_cpu/logical_shift.svg[width=\u0026#34;100%\u0026#34;]\n\nimage:../images/how_does_cpu/arithmetic_shift.svg[width=\u0026#34;100%\u0026#34;]\n\nAs you may have noticed, in the last posts we have not even mentioned \nthe two more advanced fundamental arithmetic operations multiplication and divison of integers.\nmul and div are very elaborate operations compared to addition and subtraction.\n\nSimple CPUs and microprocessors do not even have multiplier units or division units.\nThe instructions have to be programmed as a software routine, \nwe go into this in more details in another blogpost.\n(And then there is of course also floating point arithmetic, even more complex than our currently discussed\nintegers).\n\n\nThe now introduced arithmetic shift operations solves multiplication and division operations at least \nfor a subset of powers of two: \n____\nAn arithmetic left shift of a two\u0026#39;s complement value by n bits equals a multiplication by 2^n^.\n(Given no overflow is produced)\n____\n\n____\nAn arithmetic right shift equals the floor of a division by 2^n^.\n____\n\n=== A simple Shifter\nThe gate-level implementation of a simple shifter\nis shown below.\n\nimage:../images/how_does_cpu/shifter_register_level.svg[width=\u0026#34;100%\u0026#34;]\n\nNext we see the truth table for the decoder logic,\nthe derivation of the netlist is left as excercise \nfor the reader.\n\n[options=\u0026#34;header\u0026#34;]\n|==================\n| Sel1 |Sel0 | R |  nop | L\n| 0 | 0 | 0 | 1 | 0\n| 0 | 1 | 0 | 0 | 1\n| 1 | 0 | 1 | 0 | 0\n|==================\n\n\nWe see the gate-level implementation of such a shifter- is shown for\nthe operations is realised in pass-transistor-logic (Reference: VLSI\n Design by K.Lal Kishore and V.S.V Prabhakar).\n\nimage:../images/how_does_cpu/shifter_ptl.svg[width=\u0026#34;100%\u0026#34;]\n\n=== Barrel Shifter\nA more sophisticated shifter implementation is the so known barrel shifter. \nThe barrel shifter allows a shift over multiple bits in one go.\n\nAn implementation in pass-transistor-logic is shown below.\n\nimage:../images/how_does_cpu/barrel_shifter_ptl.svg[width=\u0026#34;100%\u0026#34;]\n"},{"id":49,"href":"/pages/short-introduction-to-electronics-102-de/","title":"Prequel: Einführung in die Elektrotechnik - 102","section":"Pages","content":"== Zeitsensitive Komponenten Nachdem wir im ersten Teil das wichtigste Bauteil, den Widerstand, betrachtet und ausführlich beschrieben haben Widerstand, im ersten Teil ausführlich beschrieben wurde, wollen wir uns nun das nächste wichtige Bauteil, den Kondensator, werfen. Kondensatoren sind ebenfalls passive Bauelemente, das heißt sie verstärken ein Signal nicht. === Elektrostatisches Feld Nimmt man zwei Metallflächen und stellt sie nebeneinander, mit einer kleinen dünnen Schicht einer nichtleitenden Substanz dazwischen, entsteht ein elektrostatisches Feld. Der Aufbau des elektrostatischen Feldes erfolgt über eine Gleichstromquelle, im Bild unten dargestellt durch den Generator G. Die Quellenspannung des Generators verschiebt die Elektronen, die sich im Draht und in den Metallplatten befinden. Auf diese Weise entsteht auf der rechten Platte ein Überfluss an Elektronen (-Q), während auf der anderen Platte ein Mangel der gleichen Menge, +Q, entsteht. Für kurze Zeit fließt ein Ladestrom mit dem Momentanwert i, der in umgekehrter Richtung eine Strommenge +Q fördert, eine Strommenge +Q fördert. Der Ladestrom i wird Null, wenn sich die Strommenge +Q und die -Q erzeugte Spannung gleich groß ist. Das elektrostatische Feld bleibt auch nach dem Trennen von der Gleichstromquelle bestehen, was sich mit einem einem Voltmeter mit hoher Impedanz überprüft werden kann: Das elektrostatische Feld entsteht durch die getrennten Ladungen +Q, -Q. Die vorhandene Spannung zeigt, dass in dem Feld Energie gespeichert ist. Diese Anordnung wird als Plattenkondensator bezeichnet. image:../images/electronic_basics/electrostatic_field.svg[width=300] Referenz: Dieter Zastrow, Elektrotechnik,16.Auflage, S. 120. Es ist ein weiteres elektronisches Grundelement, das häufig in elektronischen Geräten verwendet wird. Die dazwischen liegende Substanz wird als Dielektrikum bezeichnet. === Kapazität Die Grundgleichung zur Berechnung der Kapazität, der Eigenschaft Nr. 1 eines Kondensators, lautet wie folgt. Die Kapazität C des Kondensators gibt das interessante Verhältnis zwischen der gespeicherten Ladungsmenge Q und der Ladespannung spannung U_c . [„latex“,„../images/electronic_basics/Capacitance.svg“ ,imgfmt=„svg“] \\[C= \\frac{Q}{U_c}\\] === Parallel- und Reihenschaltung Bei der Parallelschaltung von Kondensatoren addieren sich die Kapazitäten zur Gesamtkapazität. [„latex“,„../images/electronic_basics/parallel_C.svg“ ,imgfmt=„svg“] \\[C= C_{1} + C_{2} + ... \\] Bei der Reihenschaltung ist der Kehrwert der Gesamtkapazität gleich der der Summe der Kehrwerte der Einzelkapazitäten. [„latex“,„../images/electronic_basics/series_C.svg“ ,imgfmt=„svg“] \\[ \\frac{1}{C}= \\frac{1}{C_{1}} + \\frac{1}{C_{2}} + ... \\] === Der Kondensator und die Spulen Die nun vorgestellten Elemente haben einen Bezug zur Statik des (ohmschen) Widerstandes. Nun rückt auch die Zeit in den Fokus, denn sowohl Kondensator als auch Spulen sind in gewissem Sinne zeitempfindliche Elemente sind. Normalerweise würden wir also mit der Einführung des Kondensators mit all seinen Implikationen beginnen, und dann zu den Spulen übergehen, die die dann anschließend eingeführt werden. Stattdessen zeigen wir in diesem Beitrag beide in einer Gegenüberstellung da sie komplementäre Eigenschaften haben. [width=„100%“ cols=„a,a“] |===== | Kondensator | Spule | image:../images/electronic_basics/capacitor.svg[width=„300px“] | image:../images/electronic_basics/coil.svg[width=„300px“] | Schaltsymbol eines Kondensators | Schaltsymbol einer Spule | Bild:../images/electronic_basics/capacitor.jpg[width=„300px“] | Bild:../images/electronic_basics/coil.jpg[width=„300px“] | speichert Energie in einem elektrischen Feld | speichert Energie in einem magnetischen Feld | führt in Phase | verzögert in Phase | blockiert im Gleichstrommodus | im Gleichstrommodus wächst der Strom, während die Spannung mit der gleichen Geschwindigkeit abgenommen wird | |===== //// - Aufbau Kondensator - Kondensator im Gleichstromkreis - RC-Glieder //// Übersetzt mit DeepL.com (kostenlose Version) == Frequenzabhängige Netzwerke (Filter) Eine häufige und sehr beliebte Anwendung von Kondensatoren sind Filter, Einfache Filter erster Ordnung, wie hier gezeigt, sind aufgebaut aus einem Widerstand und einem Kondensator aufgebaut. Als nächstes wollen wir den Frequenzgang eines Filters berechnen Frequenzgang eines Filters berechnen, indem wir die Frequenzgangfunktion ermitteln, das ist die Ausgangsspannung geteilt durch die Eingangsspannung - Dies wird anhand der folgenden Beispiele deutlicher. === Tiefpassfilter Tiefpass 1. Ordnung image:../images/electronic_basics/lowpass.svg[width=\u0026#34;400px“] Frequenzgang [„latex“, „../images/electronic_basics/lowpass_fr.svg“, imgfmt=„svg“] \\[ H(\\omega) = \\frac{U_{out}}{U_{in}} = \\frac{(1/j\\omega C)}{(R+ 1/j \\omega C)} = \\frac{(1/j\\omega C)\\cdot j \\omega C}{(R+ 1/j \\omega C) \\cdot j \\omega C } = \\frac{1}{1+ j\\omega RC } = \\frac{1}{1+ j \\omega/ \\omega_g}\\] Grenzfrequenz (mit Beispielwerten von R=1kOhm, C= 1µF) [„latex“, „../images/electronic_basics/cutoff_fr.svg“, imgfmt=„svg“] \\[ \\omega_g = \\frac{1}{RC} = \\frac{1}{1 \\cdot 10^3 \\cdot 1 \\cdot 10^6}= 10^3= 1000 \\cdot 1/s\\] image:../images/electronic_basics/lowpass_bode_diagram.svg[width=„1250px“] Um das Bode-Diagramm für den oben gezeigten Tiefpass zu erzeugen, brauchen wir eine Hilfe, Dazu installieren Sie bitte matplotlib mit dem folgenden Befehl: \u0026#39;\u0026#39;\u0026#39; pip install matplotlib \u0026#39;\u0026#39;\u0026#39; und führen Sie das folgende Python-Skript aus: [source,python] ---- import matplotlib.pyplot as plt import numpy as np # Definieren Sie die Übertragungsfunktion eines Tiefpassfilters erster Ordnung def lowpass_first_order(frequency, cutoff_frequency): return 1 / np.sqrt(1 + (frequency / cutoff_frequency)**2) # Frequenzbereich für das Bode-Diagramm (logarithmische Skala) frequency = np.logspace(0, 6, 1000) # Von 10^0 bis 10^6 Hertz # Cutoff-Frequenz des Tiefpassfilters cutoff_frequency = 1000 # Beispielwert - Sie können hier Ihren eigenen Wert einstellen # Berechnen Sie die Verstärkung in Dezibel (20 * log10(Amplitude)) gain_db = 20 * np.log10(lowpass_first_order(frequency, cutoff_frequency)) # Berechne den Phasengang in Grad (Winkel) phase_deg = np.degrees(np.arctan(-frequency / cutoff_frequency)) # Erstellen Sie das Bode-Diagramm mit Verstärkung und Phase plt.figure(figsize=(10, 6)) # Verstärkungsdiagramm (Betrag) plt.subplot(2, 1, 1) plt.semilogx(frequenz, verstärkung_db, label=\u0026#39;Verstärkung (dB)\u0026#39;) plt.ylabel(\u0026#39;Verstärkung (dB)\u0026#39;) plt.title(\u0026#39;Bode-Diagramm eines Tiefpaßfilters erster Ordnung\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() # Phasendiagramm plt.subplot(2, 1, 2) plt.semilogx(frequenz, phase_deg, label=\u0026#39;Phase (Grad)\u0026#39;) plt.xlabel(\u0026#39;Frequenz (Hz)\u0026#39;) plt.ylabel(\u0026#39;Phase (Grad)\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() plt.tight_layout() # Speichern des Bode-Diagramms als SVG-Datei plt.savefig(\u0026#39;lowpass_bode_phase.svg\u0026#39;, format=\u0026#39;svg\u0026#39;) # Optional kann das Bode-Diagramm angezeigt werden. plt.show() ---- === Hochpassfilter Hochpass 1.Ordnung image:../images/electronic_basics/highpass.svg[width=\u0026#34;400px“] Frequenzgang [„latex“, „../images/electronic_basics/highpass_fr.svg“, imgfmt=„svg“] \\[ H(\\omega) = \\frac{U_{out}}{U_{in}} = \\frac{R}{R+ 1/j\\omega C} = \\frac{j \\omega C}{1+ j \\omega RC} = \\frac{j\\omega / \\omega_g}{1+ j\\omega/ \\omega_g}\\] Grenzfrequenz (mit Beispielwerten von R=1kOhm, C= 1µF) //// [„latex“, „../images/electronic_basics/cutoff_fr.svg“, imgfmt=„svg“] \\[ \\omega_g = \\frac{1}{RC} = \\frac{1}{1 \\cdot 10^3 \\cdot 1 \\cdot 10^6}= 10^3= 1000 \\cdot 1/s\\] //// image:../images/electronic_basics/highpass_bode_diagram.svg[width=„1250px“] Und hier noch einmal das Python-Skript, dieses Mal für den Hochpass: [source,python] ---- import matplotlib.pyplot as plt import numpy as np # Definieren Sie die Übertragungsfunktion eines Hochpassfilters erster Ordnung def highpass_first_order(frequency, cutoff_frequency): return frequency / np.sqrt(1 + (frequency / cutoff_frequency)**2) # Frequenzbereich für das Bode-Diagramm (logarithmische Skala) frequency = np.logspace(0, 6, 1000) # Von 10^0 bis 10^6 Hertz # Cutoff-Frequenz des Hochpassfilters cutoff_frequency = 1000 # Beispielwert - Sie können hier Ihren eigenen Wert einstellen # Berechnen Sie die Verstärkung in Dezibel (20 * log10(Amplitude)) gain_db = 20 * np.log10(highpass_first_order(frequency, cutoff_frequency)) # Berechne den Phasengang in Grad (Winkel) phase_deg = np.degrees(np.arctan(frequency / cutoff_frequency)) # Erstellen Sie das Bode-Diagramm mit Verstärkung und Phase plt.figure(figsize=(10, 6)) # Verstärkungsdiagramm (Betrag) plt.subplot(2, 1, 1) plt.semilogx(frequenz, verstärkung_db, label=\u0026#39;Verstärkung (dB)\u0026#39;) plt.ylabel(\u0026#39;Verstärkung (dB)\u0026#39;) plt.title(\u0026#39;Bode-Diagramm eines Hochpaßfilters erster Ordnung\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() # Phasendiagramm plt.subplot(2, 1, 2) plt.semilogx(frequenz, phase_deg, label=\u0026#39;Phase (Grad)\u0026#39;) plt.xlabel(\u0026#39;Frequenz (Hz)\u0026#39;) plt.ylabel(\u0026#39;Phase (Grad)\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() plt.tight_layout() # Speichern des Bode-Diagramms als SVG-Datei plt.savefig(\u0026#39;highpass_bode_diagram.svg\u0026#39;, # Save the Bode diagram as an SVG file plt.savefig(\u0026#39;highpass_bode_diagram.svg\u0026#39;, format=\u0026#39;svg\u0026#39;) # Optionally, display the Bode diagram plt.show() ---- Aus dem englischen übersetzt mit DeepL.com"},{"id":50,"href":"/pages/prequel-short-introduction-to-electronics-de/","title":"Prequel: Introduction to electronics","section":"Pages","content":"= Einführung in die Elektronik\n\n\u0026#39;\u0026#39;\u0026#39;\nAls ich just dabei war, den Implementierungsteil der Booleschen Algebra zu schreiben, die grundlegenden logischen\nGatter, lief der Schreibprozess schnell aus dem Ruder und ich ertappte mich dabei, dass ich mehr über weniger zusammenhängende Themen schrieb\nThemen zu schreiben, wie z.B. die Erläuterung grundlegender elektronischer Komponenten und deren Implementierung auf Silizium, als über den eigentlichen Inhalt,\nhier soll der Platz für diese Ausflüge sein. Dies soll kein vollständiges Nachschlagewerk sein, eher eine Ergänzung zu\nbestehenden Literatur.\n\n\u0026#39;\u0026#39;\u0026#39;\n\n== Freie Elektronen und elektrischer Strom\n\nWas ist Elektrizität? Grob gesagt ist es der Fluss von Elektronen in einem Leiter. Laienhaft ausgedrückt kann man sagen,\nElektronen auf der äußeren Schale - auch Valenzband genannt - eines Atoms hüpfen vom Valenzband\neines Atoms zum Nachbaratom. Elektrizität ist also im Wesentlichen die Bewegung von Elektronen durch Materie.\nIn der praktischen Anwendung ist diese Materie ein Stromkreis, aber auch zum Beispiel die Blitzentladung\nauftritt, in diesem Fall kann die ionisierte Luft als (Kurz-)Stromkreis betrachtet werden.\n////\ndarüber schreiben\n\nDie folgende Tabelle zeigt die Atommodelle von Kohlenstoff-, Silizium- und Kupferleitern. Der Autor wählt diese Elemente\naufgrund ihrer interessanten Eigenschaften. Kohlenstoff und Silizium gehören zur Gruppe der Halbleiter, während Kupfer bekannt ist\nals ausgezeichneter Leiter bekannt ist. Die Leitfähigkeit von Halbleitern ist sehr unterschiedlich und hängt vom Reinheitsgrad und der Temperatur ab.\n\n////\n\n=== Wir gehen atomar vor: Leitende Elemente...\n\nDie erste Gruppe von Elementen (oder Verbindungen), die wir hier vorstellen werden, sind die Leiter.\nEinige wichtige Vertreter dieser Gruppe sind die Elemente Aluminium und Kupfer\ndie beide für elektrische Übertragungsleitungen und Stromnetze unverzichtbar sind.\nWie die folgende Tabelle zeigt, verfügen beide Elemente über freie Elektronen auf ihrer Valenz\nValenzschale freie Elektronen, die, wie oben beschrieben, benötigt werden, um den Elektronenwechsel von einem Atom zum anderen zu ermöglichen\nvon einem Atom zum anderen und damit die Bewegung von Elektronen zu ermöglichen, was das Element (in seiner reinen Form) zu einem Leiter macht.\n\nNatürlich gibt es in der realen Welt mehrere Faktoren, die den hier vorgeschlagenen idealisierten Eigenschaften entgegenwirken\nhier vorgeschlagenen Eigenschaften entgegenwirken. So müssen wir unter anderem berücksichtigen, dass Metalle oxidieren, wenn sie mit Sauerstoff in Kontakt kommen\nmit Sauerstoff oxidieren, wodurch sich eine dünne, aber effektiv isolierende Schicht auf der Oberfläche des Metalls bildet,\ndie einen guten Kontakt verhindert. Auf solche Effekte können wir später eingehen. Lassen Sie uns jetzt einfach mit dem Thema weitermachen...\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|=====\n2+\u0026gt;| conductor\n| image:../images/electronic_basics/atomic_model_Al.svg[width=\u0026#34;300px\u0026#34;]\n| image:../images/electronic_basics/atomic_model_Cu.svg[width=\u0026#34;300px\u0026#34;]\n| atomic model of aluminium (13) | atomic model of copper (28)\n| valence shell / free electron(s): 3 (3) | valence shell / free electron(s): 1 (1)\n|=====\n\nimage:../images/electronic_basics/simple_circuit.svg[width=\u0026#34;400px\u0026#34;]\n\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../images/electronic_basics/elemental_charge.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\large \\[Q = N \\cdot (\\pm e)\\]\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../images/electronic_basics/current.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\large \\[I = \\frac{\\Delta Q }{\\Delta t}\\]\n\n\n\n=== ...und nicht so leitfähig\n\nDie zweite Gruppe von Elementen, die wir hier vorstellen wollen, sind Elemente, deren\nLeitfähigkeit (stark) von ihrem Reinheitsgrad und von Umgebungs\nFaktoren wie Temperatur abhängt. Die Vertreter dieser Gruppe werden als Halbleiter bezeichnet.\nKohlenstoff und Silizium sind Beispiele, die im Periodensystem auftauchen.\nDer Autor hat diese beiden Elemente ausgewählt, da sie sehr interessante Eigenschaften haben\nin Bezug auf - aber nicht nur - die Leitfähigkeit. Dies ist auf die Anzahl der Valenzelektronen\nElektronen auf der äußeren Schale.\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|=====\n2+\u0026gt;| semiconductor \n| image:../images/electronic_basics/atomic_model_C.svg[width=\u0026#34;300px\u0026#34;]\n| image:../images/electronic_basics/atomic_model_Si.svg[width=\u0026#34;300px\u0026#34;]\n| atomic model of carbon (6) | atomic model of silicon (14)\n| valence shell / free electron(s): 4 (0) | valence shell / free electron(s): 4 (0)\n|=====\n\nWarum also haben Kohlenstoff und Silizium trotz ihrer vier Elektronen auf der Valenzschale so schlechte Leitfähigkeitseigenschaften im Vergleich zu Kupfer -trotz seiner  vier Elektronen\nauf der Valenzschale?\n\nDie Antwort liegt in der einfachen Tatsache, dass sowohl Kohlenstoff als auch Silizium ein Gitter bilden, das alle Elektronen der Valenzschale verbraucht.\nschale.\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|=====\n| covalent bonding of carbon | covalent bonding of silicon \n| image:../images/electronic_basics/covalent_bonding_c.svg[width=\u0026#34;400px\u0026#34;]\n| image:../images/electronic_basics/covalent_bonding_si.svg[width=\u0026#34;400px\u0026#34;]\n2+\u0026gt;|semiconductor | conductor\n|=====\n\n== Spannung und Potential\n\nDie folgende Tabelle zeigt die gebräuchlichen Symbole für Spannungsquellen. Auf der linken Seite\nist eine ideale Spannungsquelle dargestellt, während auf der rechten Seite eine reale Spannungsquelle\nabgebildet ist. Wie Sie sehen können, ähnelt die reale Quelle einer Batteriezelle. Natürlich kann die\nSpannungsquelle von einer tatsächlichen Batteriezelle abweichen und wird auch meist nicht implizit dargestellt.\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|=====\n| ideal voltage source | real voltage source\n| image:../images/electronic_basics/ideal_voltage_source.svg[width=\u0026#34;150px\u0026#34;]\n| image:../images/electronic_basics/real_voltage_source.svg[width=\u0026#34;150px\u0026#34;]\n|=====\n\nEine ideale Spannungsquelle liefert eine Spannung mit einem bestimmten Wert.\n\nWie wir in den unten gezeigten Schaltplänen sehen können, ist eine Spannung\neinfach die Differenz zwischen zwei Potentialen. Im ersten Beispiel (links)\nist der untere Knotenpunkt als Bezugspunkt gewählt, da er als Masse signalisiert\nwird. Die Spannung beträgt also 1,5 V für U_B0 bzw. 3 V für U_A0. Im Beispiel\nrechts hingegen wird der Übergang zwischen den Batteriezellen als Bezugspunkt\nund Masse gewählt. Die Potentialdifferenzen, die wir hier messen, sind: U_A0 = 1,5V\nund U_B0 =-1,5V. Als Anmerkung: Solche Doppelstromversorgungen - allerdings\nmit einem Spannungsbereich von 12...15V - werden häufig für Anwendungen mit Operationsverstärkern verwendet.\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|=====\n| Single power supply | Dual power supply\n| image:../images/electronic_basics/potential_l.svg[width=\u0026#34;250px\u0026#34;] | image:../images/electronic_basics/potential_ll.svg[width=\u0026#34;250px\u0026#34;]\n|=====\n\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../images/electronic_basics/potentialdifference.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\large \\[U = \\phi_{1} - \\phi_{0}\\]\n\n\n////\nSimple circuit with voltage source and resistor, bridge to next section\n////\nDas nächste Bild zeigt die einfachste mögliche Schaltung: Eine Spannungsquelle\nmit einem Widerstand in Reihe. Physikalisch gesehen ist jeder Widerstand nur ein\nWandler von elektrischer Energie in thermische Energie, also Wärme.\n\nWiderstände werden in der Regel in Schaltungen verwendet, um die Spannung auf den\ngewünschten Wert abzusenken bzw. den Strom, der zwischen bestimmten Pfaden\neiner Schaltung fließt, zu begrenzen. Wir werden im nächsten Abschnitt mehr\ndarüber erfahren.\n\n\nimage:../images/electronic_basics/resistor_circuit.svg[width=\u0026#34;250px\u0026#34;]\n\n\n== Ohmsches Gesetz und Leitungswiderstand\n\n*Übung: Widerstand messen*\nZur Durchführung der folgenden Übung benötigen Sie ein Spannungs- und ein Amperemeter (oder einfach zwei Multimeter),\neine variable Spannungsquelle und einige Probedrähte aus verschiedenen Materialien, jedoch mit gleicher Länge\nund gleichem Durchmesser. Wenn Sie nicht über die entsprechenden Geräte verfügen, können Sie diese Übung\ntheoretisch auch in http://qucs.sourceforge.net[Qucs] oder\nhttps://www.analog.com/en/design-center/design-tools-and-calculators/ltspice-simulator.html[LTspice] simulieren.\n\nDa wir aber im Voraus die Parameter der zu messenden Probedrähte festlegen müssen\nmessen wollen, torpediert dieser Ansatz gewissermaßen den Zweck der Übung, nämlich zu lernen,\nwie man eine indirekte Messung des elektrischen Widerstandes durchführt.\n\nSchließen Sie die Geräte wie in der Abbildung unten dargestellt an, wobei der Probedraht den Widerstand Rx darstellt.\n\n//.Resistance measurement principal\nimage:../images/electronic_basics/resistance_measurement_l.svg[width=550]\n\n\nMessen Sie nun für jeden Draht die Spannung und den Strom und zeichnen Sie ein Diagramm mit der\nSpannung auf der x-Achse und dem Strom auf der y-Achse.\nDu wirst sehen, dass du für verschiedene Materialien einen linearen Graphen erhältst, aber mit einer\nunterschiedlichen Steigung. Sie haben also eine Beziehung gefunden zwischen Spannung, Strom und Widerstand gefunden!\nNachdem du die verschiedenen Drähte gemessen hast, kannst du auch Stift und Papier verwenden: Zeichne eine Linie mit\nBleistift eine Linie ziehen oder eine kleine Fläche kritzeln. Verbinden Sie diese nun mit den Sonden der Messanordnung.\nSie werden sehen, dass auch die Graphitspur wie ein Leiter wirkt - nicht optimal, aber ein Leiter.\n\nDiese Beobachtung führt uns zu der wichtigsten Formel, die Ihnen in einem Elektrotechnikkurs 101 begegnen wird, dem *Ohmschen Gesetz*.\n\n[„latex“,„../images/electronic_basics/ohms_law.svg“ ,imgfmt=„svg“]\n\\groß \\[ R [\\Omega] = \\frac{U [V]}{I [A]}\\]\n\n// .Ohmsches Gesetz\n// :figure-caption: Gleichung\n\nWenn wir diese Gleichung in ihre einfacher zu interpretierende Form umstellen, U = R*I, erkennen wir,\ndass der Spannungsabfall (U) am Widerstand dem Widerstandswert ( R) mal dem durchfließenden Strom (I)\nentspricht. Wir haben noch nicht über den Strom gesprochen und werden dies auf einen späteren Abschnitt verschieben.\nWie in den Bremsen angegeben, ist die Einheit des Widerstands Ω.\n// Todo: Schreibe mehr über / zum Ohmschen Gesetz.\n\n////\nRegeln für Reihen- und Parallelschaltungen hinzufügen\n////\nIn der folgenden Abbildung sind die Regeln für die Reihen- und Parallelschaltung von Widerständen dargestellt.\nimage:../images/electronic_basics/resistor_rules.svg[width=\u0026#34;500px\u0026#34;]\n\nBei der Reihenschaltung addieren sich die Werte einfach, wie wir es schon bei den Spannungsquellen gesehen haben,\nwährend für die Parallelschaltung dasselbe gilt, allerdings für den Leitwert G, der der Kehrwert\ndes Widerstands R ist und in S(iemens) gemessen wird.\n\n////\nErklärung für die Parallelschaltung hinzufügen\n////\n\n\nWir haben also herausgefunden, dass sich die Materialien in ihrer elektrischen Leitfähigkeit - die der Kehrwert\ndes elektrischen Widerstands ist - unterscheiden.\nEinige sind gut (Leiter), einige sind ziemlich schlecht und unbrauchbar (Nichtleiter), aber dennoch nützlich\nals Dielektrikum, wie wir im nächsten Abschnitt sehen werden.\nim nächsten Abschnitt sehen werden, und einige dazwischen.\nWir müssen natürlich auch beachten, dass die Leitfähigkeit nicht nur vom Material selbst, sondern auch von seiner\n Geometrie abhängt (außerdem ist sie von der Temperatur abhängig, aber darauf gehe ich hier nicht ein),\n Sie wissen ja, dass wir uns mit Physik beschäftigen.\nin diesem Zusammenhang ist die folgende Formel von interesse:\n\n[„latex“,„../images/electronic_basics/wire_resistance.svg“ ,imgfmt=„svg“]\n\\large \\[ R = \\frac{\\rho L}{A}\\]\n\n\nFür die gebräuchlichste Rechteckform - wie ein Leiterstreifen auf einer Leiterplatte - ergibt sich die Fläche A aus Breite mal Höhe\n\n[„latex“,„../images/electronic_basics/strip_resistance.svg“ ,imgfmt=„svg“]\n\\large \\[ R = \\frac{\\rho L}{A} = \\frac{\\rho L}{w \\cdot h}\\]\n\n\nDer Gesamtwiderstand eines Drahtes oder einer Leiterbahn auf einer Leiterplatte ist also abhängig vom spezifischen Widerstand ρ, der Länge\ndes Leiters und der Fläche, die zur Übertragung des Stroms verwendet wird. Logischerweise erhöht sowohl der spezifische Widerstand als auch die Länge des Leiters\nden Widerstand erhöhen, während die Fläche dem entgegenwirkt.\n\n*Warum müssen wir das wissen?*\n\nAn dieser Stelle werden Sie sich vielleicht fragen, warum es wichtig ist, dies zu wissen, wenn wir einfach einen Schaltplan unseres Heimwerkerprojekts erstellen und es mit diskreten Bauteilen\nauf einem Breakout-Board realisieren können - die Antwort ist ganz einfach die Skalierung - für dieses einfache Bastlerbeispiel mag das funktionieren, aber es fehlt die Skalierbarkeit, die Kosten und/oder die Zuverlässigkeit.\n\nJe weiter wir in der Skala nach unten gehen, desto wichtiger werden parasitäre Effekte - wir werden in den folgenden Abschnitten mehr darüber erfahren.\n\n\u0026#39;\u0026#39;\u0026#39;\nWiderstandsmessung\n\nDie folgende Abbildung zeigt das Prinzip der Widerstandsmessung mit einem Digitalmultimeter - abgesehen vom Bereichsschalter.\nAuf der linken Seite haben wir eine Konstantstromquelle, in der Mitte den zu messenden Widerstand - oder Draht - und auf der linken Seite\nein Voltmeter, das die Spannung misst. Wie bei der Konstantstromquelle ist der Gesamtstrom im Stromkreis bekannt, der Widerstand\nkann daraus mit der gemessenen Spannung skaliert werden.\n\n// Widerstandsmessung mit einem Digitalmultimeter\nimage:../images/electronic_basics/resistance_measurement_ll.svg[width=550]\n\n\u0026#39;\u0026#39;\u0026#39;\n\n=== Der Widerstand\n\nDas elektrische Bauteil selbst gibt es in allen Formen und Größen, je nach Anwendungsbereich.\nder Miniaturwiderstand für die Aufbautechnik, der in allen höher integrierten elektronischen Geräten verwendet wird,\nder durchschnittliche 1/4-Watt-Widerstand auf Kohlebasis mit 5 Prozent Toleranz (im Bild unten mittig dargestellt)\nund die präziseren Metallfilmwiderstände mit 1 % Toleranz (blau, rechts im Bild).\nEs gibt Widerstände mit mechanisch einstellbarem Widerstand, die Potentiometer genannt werden (wie die links im Bild gezeigten).\nAndere Typen sind Varistoren, bei denen der Widerstand von der angelegten Spannung abhängt, und einige andere Typen wie\nNTC / PTC in Abhängigkeit von der Temperatur.\n\nimage:../images/electronic_basics/discrete_resistors_edit.jpg[width=550]\n\nimage:../images/electronic_basics/smd_example.jpg[width=300]\n\n////Erklärung des Aufbaus und der Konstruktion von SMD-Widerständen////\n\n////\nErkläre die ganze Sache auf einer physikalischen Ebene\nrho und Geometrie (dasselbe gilt für Kondensatoren und Spulen)\nUnd warum? Weil wir meist nicht nur mit verklumpten Bauteilen arbeiten\nsondern eher mit verteilten Bauteilen - besonders im HF-Bereich, aber\nich nicht mit HF anfangen. Netzwerk-Dingens auch - Warum brauchen wir das?\n////\n// Widerstand\n\nAus dem englischen übersetzt mit https://deepl.com[deepl]."},{"id":51,"href":"/pages/prequel-short-introduction-to-electronics/","title":"Prequel: Introduction to electronics","section":"Pages","content":"= Prequel Introduction to electronics \n\n\u0026#39;\u0026#39;\u0026#39;\nWhile I was about to write the implementation part of the boolean algebra post, the basic logic \ngates, the writing process got quickly out of hand and I caught myself to write more about less connected\ntopics like explaining basic electronic components and their implementation on silicon than the actual content,\nhere shall be the place for those excursions. This is not meant to be a complete reference more a supplement to\nexisting literature.\n\u0026#39;\u0026#39;\u0026#39;\n\n== Free electrons and electric current\n\nWhat is electricity? Broadly speaken it is the flow of electrons in a conductor. In laymans term you can say,\nelectrons on the outer shell - also called as valence band - of an atom are hopping from the valenece band \nof an atom to the adjacent one. So essentialy electricity constitutes the movement of electrons through matter.\nIn practical application this matter is an electrical circuit, but also for example the lightning discharge \noccurs, in this case the ionised air can be considered as the (short) circuit.\n\n////\nwrite about it\n\nThe table below shows the atomic models of carbon, silicon, and copper conductor. The author chooses those elements\nbased on their interesting properties. Carbon and silicon belong to the group of semiconductors while copper is known\nas excellent conductor. The conductivity of semiconductors is variable to a wide degree, dependent on its degree of purity and temperature\n\n////\n\n=== Going atomic: Conductors...\n\nThe first group of elements (or compounds) we will introduce here are the conductors.\nSome important representants of this group are the elements aluminium and copper\nwhich both are indispensible for electric transmission lines and power grids.\nAs the table below depicts, both elements have free electrons available on it\u0026#39;s valence\nshell, which as described above, are needed to allow the hopping of electrons from one atom \nto another and thus allow movement of electrons, making the element (in its pure form) a conductor.\n\nOf course in real world there are multiple factors counteracting to the idealized properties\nproposed here. E.g. we have to consider among others that metals oxide when coming in contact \nwith oxygen, which builds up a thin but effectively isolating layer on the surface of the metal,\npreventing a good contact. We might discuss such effects later. For now just let\u0026#39;s continue on the topic...\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|=====\n2+\u0026gt;| conductor\n| image:../images/electronic_basics/atomic_model_Al.svg[width=\u0026#34;300px\u0026#34;]\n| image:../images/electronic_basics/atomic_model_Cu.svg[width=\u0026#34;300px\u0026#34;]\n| atomic model of aluminium (13) | atomic model of copper (28)\n| valence shell / free electron(s): 3 (3) | valence shell / free electron(s): 1 (1)\n|=====\n\nimage:../images/electronic_basics/simple_circuit.svg[width=\u0026#34;400px\u0026#34;]\n\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../images/electronic_basics/elemental_charge.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\large \\[Q = N \\cdot (\\pm e)\\]\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../images/electronic_basics/current.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\large \\[I = \\frac{\\Delta Q }{\\Delta t}\\]\n\n\n\n=== ...and not so conductors\n\nThe second group of elements we want to introduce here are elements which \nconductivity is (highly) dependent on its purity degree and environment\nfactors like temperature. Representants of this group are called semiconductors.\nCarbon and silicon are examples showing up on the periodic table.\nThe author picked those two elements as they have very exciting properties \nin regards to - but not limited to - conductivity. This is due to the number of valence\nelectrons on the outer shell.\n\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|=====\n2+\u0026gt;| semiconductor \n| image:../images/electronic_basics/atomic_model_C.svg[width=\u0026#34;300px\u0026#34;]\n| image:../images/electronic_basics/atomic_model_Si.svg[width=\u0026#34;300px\u0026#34;]\n| atomic model of carbon (6) | atomic model of silicon (14)\n| valence shell / free electron(s): 4 (0) | valence shell / free electron(s): 4 (0)\n|=====\n\n\nSo why does carbon and silicon have so poor conductivity properties compared to copper despite their four electrons \non the valence shell electrons? \n\nThe answer lies in the simple fact, that both carbon as well as silicon form a lattice, using up all electrons of the valence\nshell.\n\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|=====\n| covalent bonding of carbon | covalent bonding of silicon \n| image:../images/electronic_basics/covalent_bonding_c.svg[width=\u0026#34;400px\u0026#34;]\n| image:../images/electronic_basics/covalent_bonding_si.svg[width=\u0026#34;400px\u0026#34;]\n2+\u0026gt;|semiconductor | conductor\n|=====\n\n== Voltage and potential\n\nThe table below shows the common symbols for voltage sources. On the left side \nan ideal voltage source is shown, while on the right side a real voltage source \nis  shown. As you can see the real source resembles a battery cell. Of course the\nvoltage source can differ from an actual battery cell, and also most often is not displayed implicit.\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|=====\n| ideal voltage source | real voltage source\n| image:../images/electronic_basics/ideal_voltage_source.svg[width=\u0026#34;150px\u0026#34;]\n| image:../images/electronic_basics/real_voltage_source.svg[width=\u0026#34;150px\u0026#34;]\n|=====\n\nAn ideal voltage source provides a voltage of a certain level. \n\nAs we can see in below shown circuit schematics a voltage is just the difference between two potentials.\nIn the first example (left) the junction at the bottom is choosen as reference point, as it \nis signaled as ground. So the voltage amounts to 1.5V for U_B0 respectively to 3V for U_A0. \nWhereas in the example on the right the junction between the battery cells is choosen as reference point and ground. \nThe potential differences we measure  here are: U_A0 = 1.5V and U_B0 =-1.5V.\nAs a remark dual power supplies like that with - however with a voltage range of 12...15V - are often used for\napplications with op-amps.\n\n[width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;]\n|=====\n| Single power supply | Dual power supply\n| image:../images/electronic_basics/potential_l.svg[width=\u0026#34;250px\u0026#34;] | image:../images/electronic_basics/potential_ll.svg[width=\u0026#34;250px\u0026#34;]\n|=====\n\n\n[\u0026#34;latex\u0026#34;, \u0026#34;../images/electronic_basics/potentialdifference.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;]\n\\large \\[U = \\phi_{1} - \\phi_{0}\\]\n\n\n////\nSimple circuit with voltage source and resistor, bridge to next section\n////\nThe next image shows the simplest possible circuit: A voltage source with a resistor in series.\nPhysically seen every resistor is just a  converter from electrical energy to thermically energy, thus heat. \n\nResistors are generally used in circuits to drop the voltage to the desired level, respectively\nlimit the current flowing between certail paths of a circuits. We will learn about it in the next section.\n\nimage:../images/electronic_basics/resistor_circuit.svg[width=\u0026#34;250px\u0026#34;]\n\n\n== Ohm\u0026#39;s law and lead resistance \n\n*Exercise: Measure Resistance* \nTo execute the following exercise you need one voltagemeter and one amperemeter (or just two multimeters), a variable voltage source and\nsome sample wires of different materials but same in length and diameter.\nIf you do not have the equipment, in theory you could also simulate this exercise in http://qucs.sourceforge.net[Qucs] or \nhttps://www.analog.com/en/design-center/design-tools-and-calculators/ltspice-simulator.html[LTspice]. \n\nBut as we need to upfront define the parameters of sample wires we want\nto measure, this approach kinda torpedoes the purpose of the exercise, of learning how to do an indirect measurement of electrical\nresistance.\n\nConnect the equipment according to the figure shown below, with the sample wire as the resistor Rx. \n\n//.Resistance measurement principal\nimage:../images/electronic_basics/resistance_measurement_l.svg[width=550]\n\n\nNow, for every wire measure the voltage and the current and plot a graph of it with voltage on x-axis and current on y-axis. \nYou will see that for different materials, you get a linear graph but with a different slope. So you have find a relation \nbetween voltage current and resistance. In addition after measuring the different wires you can also use pen \u0026amp; paper: draw a line with \na pencil or scribble a small area. Now connect these with the probes of the measurement assembly. You will see, that also\nthe graphit trace work as a conductor - not an optimal one but a conductor. \n\nThis observance leads us to the most important formula you will encounter in an electrical engineering 101 course, Ohm\u0026#39;s law.\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/electronic_basics/ohms_law.svg\u0026#34; ,imgfmt=\u0026#34;svg\u0026#34;]\n\\large \\[ R [\\Omega] = \\frac{U [V]}{I [A]}\\]\n\n// .Ohm\u0026#39;s law\n// :figure-caption: Equation\n\nWhen we rearrange this equation to its simpler interpretable form, U = R·I, we recognize, that the voltage drop (U) on the Resistor corresponds \nto the resistance value ( R) times the current flowing thru (I). We did not speak about the current yet and we will postpone this to a later section.\nAs indicated in the brakets the unit of Resistance is Ω.\n// Todo: write more about / to the ohms law.\n\n////\nAdd rules for series and parallel wiring\n////\nIn the image below the rules for series and parallel connection of resistors are shown.\n\nimage:../images/electronic_basics/resistor_rules.svg[width=\u0026#34;500px\u0026#34;]\n\nFor the series connection the values simply adds up like we have seen it for the voltage sources,\nwhile for the parallel connection see same applies, however for the conductance G which is the reciproce\nof the resistance R and measured in S(iemens).\n\n////\nAdd explanation for parallel connection\n////\n\n\nSo we discovered that the materials differ in their electrical conductivity - which is the reciprocal of the electrical resistance -\nsome are good (conductor) some are pretty bad and unusable (non-conductor) but nevertheless useful as dielectric, as we will see in\nthe next section and some in between. \nWe also need to note, of course that the conductivity is not only dependent on the material itself but also its geometries (further it is\nalso dependent on the temperature, but I will not go into this here), you know we handle with physics, so another useful formula / equation \nin this context is the following.\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/electronic_basics/wire_resistance.svg\u0026#34; ,imgfmt=\u0026#34;svg\u0026#34;]\n\\large \\[ R = \\frac{\\rho L}{A}\\]\n\n\nFor the most common rectangle form - like a strip conductor on a PCB  - area A resolves to width times height\n\n[\u0026#34;latex\u0026#34;,\u0026#34;../images/electronic_basics/strip_resistance.svg\u0026#34; ,imgfmt=\u0026#34;svg\u0026#34;]\n\\large \\[ R = \\frac{\\rho L}{A} = \\frac{\\rho L}{w \\cdot h}\\]\n\n\nSo the total resistance of a wire or a strip conductor on a PCB is dependent upon the specific resistivity ρ, the length\nof the conductor and the area used to transfer the current. Logically the specific resistivity as well as the length of the conductor \nincreases the resistance while the area counteracts it.\n\n*Why do we need to know this?*\n\nAt this point you may ask why it is important to know this if we can just pull a schematic of our DIY project and realize it with discrete components \non a breakout board- the answer is simple scale - it might work for this simple hobbyist example but lack scalibility,costs and / or reliability.\n\nThe further we get down on scale the more important parasitic effects become - we will learn about it in the subsequent sections.\n\n\u0026#39;\u0026#39;\u0026#39;\nResistance measurement\n\nBelow figure shows the principal of resistance measurement applied within a digital multimeter - leaving aside the range switch.\nOn the left side we have a constant current source, in the middle the resistor - or wire under measurement and on the left \na voltmeter measuring the voltage. As with the constant current source the overall current in the circuit is known, the resistance \ncan be scaled from that with the voltage measured.\n\n// .Resistance measurement applied in a digital multimeter\nimage:../images/electronic_basics/resistance_measurement_ll.svg[width=550]\n\n\u0026#39;\u0026#39;\u0026#39;\n\n=== The Resistor\n\nThe electrical component itself comes in all shapes and sizes dependent on the area of application.\nthe miniature ones for surface mounted devices technique, used in all higher integrated electronic devices, \nthe average 1/4 Watt resistor based on coal with 5 percent tolerance ( in the picture below shown central) \nand the more precise metal film resistors with 1 percent tolerance (blue, shown right in the picture).\nThere are resistors with mechanically adjustable resistance called potentiometer (like the ones shown left in the picture )\nOther types are varistor where the resistance is dependent upon the voltage applied, some other types like \nNTC / PTC depending on the temperature.\n\nimage:../images/electronic_basics/discrete_resistors_edit.jpg[width=550]\n\nimage:../images/electronic_basics/smd_example.jpg[width=300]\n\n////Explain structure and costruction of smd resistors////\n\n//// \nExplain this whole thing on a physical level \nrho and geometry thing (same for Capacitors and coils)\nWhy? Because mostly we not only handle lumped components\nbut rather distributed ones - especially in HF but dont get \nme started about HF. Network thingies also - Why do we need this? \n////\n"},{"id":52,"href":"/pages/short-introduction-to-electronics-102/","title":"Prequel: Introduction to electronics - 102","section":"Pages","content":"== Time-sensitive components After reviewing and extensively describing the most important component, the resistor, in the first part, now we want to have a look at the next important component, the capacitor. Capacitor are also passive components, meaning they do not amplify a signal. === Electrostatic field If we take two metal planes and park them side by side, with a small thin layer of a non-conducting substance in-between, we created an electrostatic field. The build-up of the electrostatic field happens via a DC source, in the image below depicted by the generator G. The source voltage of the generator shifts th electrons located in the wire and the metal plates. This way on the right plate originates an overflowm of electrons (-Q) , while on the other plate a ahortage of the same amount, +Q, originates. For a short amount of time, a charging current flows with the instantaneous value i, which in tradtional direction, promotes a quantity of electricity +Q. The charging current i becomes zero, if the quantity of electricity +Q and -Q generated voltage equals out. The electrostatic field endures after detachment from the DC source, which can be verified with a high impedance voltmeter.The conclusion: The electrostatic field originates by the separated loads +Q, -Q. THe existing voltage shows, that energy is stored in the field. This arrangement is called a plate capacitor. image:../images/electronic_basics/electrostatic_field.svg[width=300] Reference: Dieter Zastrow, Elektrotechnik,16.Auflage, p. 120. It is another basic electronic component, oftentimes used in electronic devices. The substance in-between is called a dielectricum. === Capacitance The basic equation for computing the capacity, the no.-1 property of a condensator is a follows. The capacity C of the capacitor gives the interesting ratio of the stored charge quantity Q to the charging voltage U_c . [\u0026#34;latex\u0026#34;,\u0026#34;../images/electronic_basics/Capacitance.svg\u0026#34; ,imgfmt=\u0026#34;svg\u0026#34;] \\[C= \\frac{Q}{U_c}\\] === Parallel- and series circuit In parallel connection of capacitors, the capacitances add up to the total capacitance. [\u0026#34;latex\u0026#34;,\u0026#34;../images/electronic_basics/parallel_C.svg\u0026#34; ,imgfmt=\u0026#34;svg\u0026#34;] \\[C= C_{1} + C_{2} + ... \\] In series connection, the reciprocal of the total capacitance is equal to the sum of the reciprocals of the individual capacitances. [\u0026#34;latex\u0026#34;,\u0026#34;../images/electronic_basics/series_C.svg\u0026#34; ,imgfmt=\u0026#34;svg\u0026#34;] \\[ \\frac{1}{C}= \\frac{1}{C_{1}} + \\frac{1}{C_{2}} + ... \\] === The Capacitor and Coils The elements next introduced, have a clue compared to the static of (ohmic) resistor. Now the time comes into focus, too, since capacitator and coils are both in a sense time-sensitive elements. So normally we would start with introducing the Capacitor with all its implication, and then go over to the coils wich are introduced then afterwards. Instead for this post, we show both of them in a comparision as they have complementary properties. [width=\u0026#34;100%\u0026#34; cols=\u0026#34;a,a\u0026#34;] |===== | conductor | coil | image:../images/electronic_basics/capacitor.svg[width=\u0026#34;300px\u0026#34;] | image:../images/electronic_basics/coil.svg[width=\u0026#34;300px\u0026#34;] | circuit symbol of a capacitor | circuit symbol of a coil | image:../images/electronic_basics/capacitor.jpg[width=\u0026#34;300px\u0026#34;] | image:../images/electronic_basics/coil.jpg[width=\u0026#34;300px\u0026#34;] | stores energy in electrical field | stores energy in a magnetic field | leads in phase | lags in phase | blocks in DC Mode | in DC mode current is growing while, voltage is taken done, with the same rate | |===== //// - Aufbau Kondensator - Kondensator im Gleichstromkreis - RC-Glieder //// == Frequency-dependent networks (Filters) An often and very popular application of capacitors are filters, Simple filters of first order like shown here,are build up from one resistor and one capacitor. Next we want to compute the frequency response of a filter by getting the frequency response function, which is the outgoing voltage divided by the in-going voltage - this becomes clearer with the following examples. === Lowpass Filter 1.order lowpass image:../images/electronic_basics/lowpass.svg[width=\u0026#34;400px\u0026#34;] frequency response [\u0026#34;latex\u0026#34;, \u0026#34;../images/electronic_basics/lowpass_fr.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;] \\[ H(\\omega) = \\frac{U_{out}}{U_{in}} = \\frac{(1/j\\omega C)}{(R+ 1/j \\omega C)} = \\frac{(1/j\\omega C)\\cdot j \\omega C}{(R+ 1/j \\omega C) \\cdot j \\omega C } = \\frac{1}{1+ j\\omega RC } = \\frac{1}{1+ j \\omega/ \\omega_g}\\] cutoff frequency (with example values of R=1kOhm, C= 1µF) [\u0026#34;latex\u0026#34;, \u0026#34;../images/electronic_basics/cutoff_fr.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;] \\[ \\omega_g = \\frac{1}{RC} = \\frac{1}{1 \\cdot 10^3 \\cdot 1 \\cdot 10^6}= 10^3= 1000 \\cdot 1/s\\] image:../images/electronic_basics/lowpass_bode_diagram.svg[width=\u0026#34;1250px\u0026#34;] We have to use some help to generate the Bode diagram for the lowpass shown above, to do that, please install matplotlib via the following command: \u0026#39;\u0026#39;\u0026#39; pip install matplotlib \u0026#39;\u0026#39;\u0026#39; and execute the following python script: [source,python] ---- import matplotlib.pyplot as plt import numpy as np # Define the transfer function of a first-order low-pass filter def lowpass_first_order(frequency, cutoff_frequency): return 1 / np.sqrt(1 + (frequency / cutoff_frequency)**2) # Frequency range for the Bode diagram (logarithmic scale) frequency = np.logspace(0, 6, 1000) # From 10^0 to 10^6 Hertz # Cutoff frequency of the low-pass filter cutoff_frequency = 1000 # Example value - You can set your own value here # Calculate the gain in decibels (20 * log10(Amplitude)) gain_db = 20 * np.log10(lowpass_first_order(frequency, cutoff_frequency)) # Calculate the phase response in degrees (angle) phase_deg = np.degrees(np.arctan(-frequency / cutoff_frequency)) # Create the Bode diagram with both gain and phase plt.figure(figsize=(10, 6)) # Gain plot (magnitude) plt.subplot(2, 1, 1) plt.semilogx(frequency, gain_db, label=\u0026#39;Gain (dB)\u0026#39;) plt.ylabel(\u0026#39;Gain (dB)\u0026#39;) plt.title(\u0026#39;Bode Diagram of a First-Order Low-Pass Filter\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() # Phase plot plt.subplot(2, 1, 2) plt.semilogx(frequency, phase_deg, label=\u0026#39;Phase (degrees)\u0026#39;) plt.xlabel(\u0026#39;Frequency (Hz)\u0026#39;) plt.ylabel(\u0026#39;Phase (degrees)\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() plt.tight_layout() # Save the Bode diagram as an SVG file plt.savefig(\u0026#39;lowpass_bode_phase.svg\u0026#39;, format=\u0026#39;svg\u0026#39;) # Optionally, display the Bode diagram plt.show() ---- === Highpass Filter 1.order highpass image:../images/electronic_basics/highpass.svg[width=\u0026#34;400px\u0026#34;] frequency response [\u0026#34;latex\u0026#34;, \u0026#34;../images/electronic_basics/highpass_fr.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;] \\[ H(\\omega) = \\frac{U_{out}}{U_{in}} = \\frac{R}{R+ 1/j\\omega C} = \\frac{j \\omega C}{1+ j \\omega RC} = \\frac{j\\omega / \\omega_g}{1+ j\\omega/ \\omega_g}\\] cutoff frequency (with example values of R=1kOhm, C= 1µF) //// [\u0026#34;latex\u0026#34;, \u0026#34;../images/electronic_basics/cutoff_fr.svg\u0026#34;, imgfmt=\u0026#34;svg\u0026#34;] \\[ \\omega_g = \\frac{1}{RC} = \\frac{1}{1 \\cdot 10^3 \\cdot 1 \\cdot 10^6}= 10^3= 1000 \\cdot 1/s\\] //// image:../images/electronic_basics/highpass_bode_diagram.svg[width=\u0026#34;1250px\u0026#34;] And here again the python script, this time for the high-pass: [source,python] ---- import matplotlib.pyplot as plt import numpy as np # Define the transfer function of a first-order high-pass filter def highpass_first_order(frequency, cutoff_frequency): return frequency / np.sqrt(1 + (frequency / cutoff_frequency)**2) # Frequency range for the Bode diagram (logarithmic scale) frequency = np.logspace(0, 6, 1000) # From 10^0 to 10^6 Hertz # Cutoff frequency of the high-pass filter cutoff_frequency = 1000 # Example value - You can set your own value here # Calculate the gain in decibels (20 * log10(Amplitude)) gain_db = 20 * np.log10(highpass_first_order(frequency, cutoff_frequency)) # Calculate the phase response in degrees (angle) phase_deg = np.degrees(np.arctan(frequency / cutoff_frequency)) # Create the Bode diagram with both gain and phase plt.figure(figsize=(10, 6)) # Gain plot (magnitude) plt.subplot(2, 1, 1) plt.semilogx(frequency, gain_db, label=\u0026#39;Gain (dB)\u0026#39;) plt.ylabel(\u0026#39;Gain (dB)\u0026#39;) plt.title(\u0026#39;Bode Diagram of a First-Order High-Pass Filter\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() # Phase plot plt.subplot(2, 1, 2) plt.semilogx(frequency, phase_deg, label=\u0026#39;Phase (degrees)\u0026#39;) plt.xlabel(\u0026#39;Frequency (Hz)\u0026#39;) plt.ylabel(\u0026#39;Phase (degrees)\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() plt.tight_layout() # Save the Bode diagram as an SVG file plt.savefig(\u0026#39;highpass_bode_diagram.svg\u0026#39;, format=\u0026#39;svg\u0026#39;) # Optionally, display the Bode diagram plt.show() ---- "}]